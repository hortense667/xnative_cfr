<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Xnative/Timeline 1.0</title>
<style>
  :root { --bg:#fafafa; --grid:#d0d0d0; --axis:#888; --text:#222; }
  html,body{height:100%; margin:0}
  html{overflow-x:hidden}
  body{display:flex;flex-direction:column;min-height:100%;font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans JP,sans-serif;color:var(--text);background:var(--bg);overflow-x:hidden}
  header{flex-shrink:0;position:sticky;top:0;z-index:10;background:#fff;border-bottom:1px solid #e5e5e5;display:flex;gap:12px;align-items:center;padding:10px 12px;flex-wrap:wrap}
  header .btn{padding:6px 10px;border:1px solid #ccc;border-radius:8px;background:#f7f7f7;cursor:pointer}
  header .btn:active{transform:translateY(1px)}
  header .legend{display:flex;gap:8px;align-items:center;margin-left:auto}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border-radius:999px;border:1px solid #ddd;background:#fff;cursor:pointer}
  /* 小さな丸ボタン */
  .chipCircle{ width:28px; height:28px; padding:0; display:inline-flex; align-items:center; justify-content:center; border-radius:999px; }
  .chipCircle .dot{ width:14px; height:14px; border-radius:999px; }
  .chip .dot{width:12px;height:12px;border-radius:999px}
  .chip .dot.blue{background:#4da3ff}.chip .dot.red{background:#ff3333}
  .chip.off{opacity:.35}
  .filters{display:flex; gap:8px; align-items:center; }
  .filters label{display:none}
  .filters select{padding:6px 8px; border:1px solid #ccc; border-radius:8px; background:#fff;}
  #eraBtn{display:none}
  .search{display:flex; gap:6px; align-items:center; margin-left:auto}
  .search input{padding:6px 8px; border:1px solid #ccc; border-radius:8px; min-width:120px; max-width:150px; width:100%}
  .viewport{flex:1;min-height:0;width:100%;overflow:auto;background:#fff;user-select:none;-webkit-user-select:none}
  .stage{width:2400px;height:2600px;transform-origin:0 0}
  .tooltip{position:absolute;background:#fff;border:1px solid #ccc;padding:8px 10px;border-radius:8px;box-shadow:0 4px 16px rgba(0,0,0,.08);pointer-events:none;font-size:12px;z-index:20}
  .hint{font-size:12px;color:#666}
  .handle{cursor:ns-resize}
  .axisLabel{font-weight:700;fill:#9a9a9a;font-size:40px;opacity:.6}
  .eventLabel{font-size:13px;fill:#c00}
  .eventMulti{fill:#c00}
  .gridMinor{stroke:var(--grid);stroke-width:1}
  .gridMajor{stroke:#b0b0b0;stroke-width:1.5}
  .ageAxis,.birthAxis{stroke:var(--axis);stroke-width:2}
  .ageTickText{font-size:18px;fill:#4a4a4a;font-weight:700}
  .eventColBg{fill:#fafafa}
  .eventColBorder{stroke:#e5e5e5;stroke-width:1}
  .handleLane{fill:#f4f9ff}
  .handleLaneBorder{stroke:#d7e8ff;stroke-width:1}
  .editAreaHint{font-size:12px;fill:#888}
  body.dragging{user-select:none;-webkit-user-select:none}
  /* エディタ（テキスト） */
  .editor{ position:absolute; background:#fff; border:1px solid #ccc; border-radius:10px; box-shadow:0 12px 28px rgba(0,0,0,.18); padding:10px; width:520px; z-index:30; }
  .editor h4{ margin:0 0 6px; font-size:14px; display:flex; align-items:center; gap:8px; justify-content:space-between; }
  .editor .fmt{ font:12px/1.2 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; color:#555; background:#f4f4f4; border:1px solid #e0e0e0; border-radius:6px; padding:2px 6px; }
  .editor textarea{ width:100%; min-height:200px; font:12px/1.5 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; padding:8px; border:1px solid #d0d0d0; border-radius:8px; box-sizing:border-box; resize:vertical; white-space:pre-wrap; overflow-x:hidden; overflow-y:auto; word-break:break-word; }
  .editor .row{ display:flex; gap:8px; justify-content:space-between; align-items:center; margin-top:8px; }
  .editor .row .left{ color:#666; font-size:12px; }
  .editor .row button{ padding:6px 10px; border:1px solid #bbb; border-radius:8px; background:#f5f5f5; cursor:pointer; }
  /* 検索反転 */
  .hlText{ fill:#fff !important; }

  /* カスタム右クリックメニュー */
  #customContextMenu{
    position:fixed;
    min-width:160px;
    background:#fff;
    border:1px solid #ccc;
    border-radius:8px;
    box-shadow:0 8px 24px rgba(0,0,0,.18);
    font-size:13px;
    padding:4px 0;
    z-index:3000;
    display:none;
  }
  #customContextMenu button{
    display:block;
    width:100%;
    padding:6px 14px;
    text-align:left;
    background:#fff;
    border:0;
    cursor:pointer;
  }
  #customContextMenu button:hover{
    background:#f0f4ff;
  }

  /* モーダル */
  .modalOverlay{ position:fixed; inset:0; background:rgba(0,0,0,.35); display:none; z-index:2000; align-items:center; justify-content:center; }
  .modal{ background:#fff; width:min(880px, calc(100% - 32px)); max-height:84vh; overflow:auto; border-radius:12px; box-shadow:0 24px 80px rgba(0,0,0,.25); }
  .modal header{ position:sticky; top:0; background:#fff; border-bottom:1px solid #eee; padding:12px 16px; display:flex; align-items:center; justify-content:space-between; }
  .modal header h3{ margin:0; font-size:16px; }
  .modal .content{ padding:16px 18px; font-size:18px; line-height:1.8; }
  .modal .content h4{ margin:14px 0 6px; font-size:15px; }
  .modal .content p{ margin:8px 0; }
  .modal .content ul{ margin:6px 0 6px 22px; }
  .modal .content code{ background:#f6f6f6; border:1px solid #e3e3e3; padding:1px 4px; border-radius:4px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  .modal footer{ padding:10px 16px 16px; display:flex; justify-content:flex-end; }
  .modal footer .btn{ background:#f6f6f6; border:1px solid #ddd; border-radius:10px; padding:6px 10px; cursor:pointer; }
  .modal footer .btn.btn-primary{ background:#007bff; border-color:#007bff; color:#fff; padding:10px 24px; font-size:18px; font-weight:600; }
  .credit{ font-size:12px; color:#777; margin-top:8px; }

  /* 診断フロー用配色（若者向け・読みやすさ維持） */
  :root {
    --diag-bg: #f8fafc;
    --diag-card: #ffffff;
    --diag-card-border: #e0e7ff;
    --diag-accent: #6366f1;
    --diag-accent-hover: #4f46e5;
    --diag-success: #0d9488;
    --diag-success-hover: #0f766e;
    --diag-dark: #312e81;
    --diag-dark-surface: #1e1b4b;
    --diag-text: #1e293b;
    --diag-text-muted: #475569;
    --diag-highlight: #a5b4fc;
    --diag-teal-light: #2dd4bf;
  }
  .kiosk-diagnosing{ text-align:center; padding:32px 24px; font-size:18px; color:var(--diag-text); }
  .kiosk-diagnosing .spinner{ width:48px; height:48px; margin:0 auto 20px; border:4px solid #e0e7ff; border-top-color:var(--diag-accent); border-radius:50%; animation:kiosk-spin 0.9s linear infinite; }
  @keyframes kiosk-spin{ to{ transform:rotate(360deg); } }

  /* キオスク体験モード UI */
  body.kiosk-mode #editor{ display:none !important; }
  #kioskStartOverlay{
    position:fixed;
    inset:0;
    background:rgba(30,27,75,.5);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:1500;
  }
  #kioskStartOverlay .inner{
    background:var(--diag-card);
    color:var(--diag-text);
    max-width:720px;
    padding:24px 28px;
    border-radius:16px;
    box-shadow:0 24px 80px rgba(99,102,241,.12), 0 0 0 1px var(--diag-card-border);
    font-size:18px;
    line-height:1.8;
    border-left:4px solid var(--diag-accent);
    box-sizing:border-box;
  }
  @media (max-width: 768px) {
    #kioskStartOverlay{
      align-items:flex-start;
      overflow-y:auto;
      -webkit-overflow-scrolling:touch;
      padding:12px 0;
    }
    #kioskStartOverlay .inner{
      max-width:calc(100vw - 24px);
      margin:12px auto;
      padding:18px 16px;
    }
    #kioskStartOverlay h2{
      font-size:18px !important;
      word-wrap:break-word;
      overflow-wrap:break-word;
    }
  }
  #kioskStartOverlay h2{
    margin:0 0 8px;
    font-size:20px;
    color:var(--diag-text);
  }
  #kioskStartOverlay .actions{
    margin-top:18px;
    text-align:right;
  }
  #kioskStartOverlay button{
    padding:10px 20px;
    border-radius:12px;
    border:none;
    background:var(--diag-accent);
    color:#fff;
    cursor:pointer;
    font-size:15px;
    font-weight:600;
  }
  #kioskStartOverlay button:hover{
    background:var(--diag-accent-hover);
  }
  #kioskHint{
    position:fixed;
    right:12px;
    bottom:12px;
    max-width:360px;
    background:var(--diag-dark);
    color:#fff;
    border-radius:16px;
    box-shadow:0 10px 40px rgba(49,46,129,.5);
    padding:14px 18px;
    font-size:18px;
    z-index:1400;
  }
  #kioskHint strong{
    display:block;
    margin-bottom:6px;
    font-size:18px;
  }
  #kioskHint button{
    margin-top:8px;
    padding:8px 14px;
    border-radius:999px;
    border:none;
    background:var(--diag-teal-light);
    color:var(--diag-dark);
    cursor:pointer;
    font-weight:600;
  }
  #kioskHint button:hover{
    background:#5eead4;
  }
  #kioskHint .count{
    font-size:18px;
    color:var(--diag-highlight);
    margin-top:6px;
  }
  /* スマホ・ステップ3で操作開始後: 診断へ＋選択数だけの1行表示 */
  #kioskHint.kiosk-hint-step3-compact {
    display: flex !important;
    flex-direction: row;
    align-items: center;
    gap: 12px;
    flex-wrap: nowrap;
  }
  #kioskHint.kiosk-hint-step3-compact #kioskFinishBtn { order: 1; }
  #kioskHint.kiosk-hint-step3-compact .count { order: 2; margin-top: 0; font-size: 16px; color: #fff; }
  #kioskHint.kiosk-hint-step3-compact .kiosk-year-controls { order: 3; display: flex !important; align-items: center; gap: 6px; }
  #kioskHint.kiosk-hint-step3-compact .kiosk-year-controls button { padding: 6px 10px; font-size: 14px; }
  /* ニックネームパッド: PCでは文字種とアクションを1行に */
  @media (min-width: 768px) {
    .kiosk-pad-modes-inner { flex-direction: row !important; justify-content: space-between !important; align-items: center !important; }
    .kiosk-pad-mode-row { margin-bottom: 0 !important; }
    .kiosk-pad-action-row { width: auto !important; }
  }
  /* ステップごとの上部メッセージ（反転色） */
  #kioskStepOverlay{
    position:fixed;
    top:72px;
    left:50%;
    transform:translateX(-50%);
    max-width:calc(100vw - 24px);
    background:var(--diag-dark);
    color:#fff;
    padding:8px 16px;
    border-radius:999px;
    font-size:18px;
    font-weight:600;
    z-index:1450;
    box-shadow:0 8px 32px rgba(49,46,129,.45);
    display:none;
    box-sizing:border-box;
  }
  @media (max-width: 768px) {
    #kioskStepOverlay{
      left:12px;
      right:12px;
      transform:none;
      width:auto;
      max-width:none;
      border-radius:12px;
      font-size:15px;
      padding:10px 14px;
      text-align:center;
    }
  }
  .kiosk-qr-box{
    margin-top:8px;
    width:160px;
    height:160px;
    background:var(--diag-bg);
    border:1px solid var(--diag-card-border);
    border-radius:8px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:12px;
    color:var(--diag-text-muted);
  }
  /* 個人レポートQR表示用オーバーレイ（スマホで撮影しやすい大きさ） */
  #kioskQrPersonalOverlay{
    position:fixed;
    inset:0;
    background:var(--diag-dark-surface);
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    z-index:2100;
    padding:24px;
    gap:24px;
  }
  #kioskQrPersonalOverlay .kiosk-qr-img{
    background:var(--diag-card);
    padding:20px;
    border-radius:12px;
    box-shadow:0 8px 32px rgba(99,102,241,.15);
  }
  #kioskQrPersonalOverlay .kiosk-qr-img img{
    display:block;
    width:min(520px, 90vw);
    height:min(520px, 90vw);
  }
  #kioskQrPersonalOverlay .kiosk-qr-close{
    padding:12px 32px;
    font-size:18px;
    border-radius:10px;
    border:1px solid var(--diag-card-border);
    background:var(--diag-card);
    color:var(--diag-text);
    cursor:pointer;
    font-weight:600;
  }
  #kioskQrPersonalOverlay .kiosk-qr-close:hover{ background:var(--diag-bg); }

  /* ===== 診断フロー時：キオスク開始オーバーレイ（body.kiosk-mode 前のウィザード）===== */
  body.kiosk-mode #kioskStartOverlay{
    background:rgba(30,27,75,.5);
  }
  body.kiosk-mode #kioskStartOverlay .inner{
    background:var(--diag-card);
    color:var(--diag-text);
    border:1px solid var(--diag-card-border);
    border-left:4px solid var(--diag-accent);
    box-shadow:0 24px 80px rgba(99,102,241,.12);
  }
  body.kiosk-mode #kioskStartOverlay .inner h2{
    color:var(--diag-text);
  }
  body.kiosk-mode #kioskStartOverlay .inner a{
    color:var(--diag-accent);
  }
  body.kiosk-mode #kioskStartOverlay .inner input,
  body.kiosk-mode #kioskStartOverlay .inner textarea,
  body.kiosk-mode #kioskStartOverlay .inner select{
    background:#fff;
    color:var(--diag-text);
    border:1px solid var(--diag-card-border) !important;
  }
  body.kiosk-mode #kioskStartOverlay .inner button{
    background:var(--diag-accent);
    color:#fff;
    border:none;
  }

  body.kiosk-mode #kioskHint{
    background:var(--diag-dark);
    color:#fff;
    box-shadow:0 10px 40px rgba(49,46,129,.5);
  }
  body.kiosk-mode #kioskHint button{
    background:var(--diag-teal-light);
    color:var(--diag-dark);
    border:none;
  }
  body.kiosk-mode #kioskHint .count{
    color:var(--diag-highlight);
  }
  body.kiosk-mode #kioskStepOverlay{
    background:var(--diag-dark);
    color:#fff;
  }

  body.kiosk-mode .modalOverlay{
    background:rgba(30,27,75,.4);
  }
  body.kiosk-mode .modal{
    background:var(--diag-card);
    color:var(--diag-text);
    border:1px solid var(--diag-card-border);
    box-shadow:0 24px 80px rgba(99,102,241,.15);
  }
  body.kiosk-mode .modal header{
    background:var(--diag-bg);
    border-bottom:1px solid var(--diag-card-border);
  }
  body.kiosk-mode .modal header h3{
    color:var(--diag-text);
  }
  body.kiosk-mode .modal .content{
    color:var(--diag-text);
  }
  body.kiosk-mode .modal .content a{
    color:var(--diag-accent);
  }
  body.kiosk-mode .modal .content code{
    background:var(--diag-bg);
    border-color:var(--diag-card-border);
    color:var(--diag-text);
  }
  body.kiosk-mode .modal footer .btn{
    background:var(--diag-bg);
    color:var(--diag-text);
    border:1px solid var(--diag-card-border);
  }
  body.kiosk-mode .modal footer .btn:hover{
    background:#e0e7ff;
  }
  body.kiosk-mode .modal footer .btn.btn-primary{
    background:var(--diag-accent);
    border-color:var(--diag-accent);
    color:#fff;
  }
  body.kiosk-mode .modal footer .btn.btn-primary:hover{
    background:var(--diag-accent-hover);
  }

  body.kiosk-mode #probeEventsPanel{
    background:#fff;
    color:#222;
    border:1px solid #ddd;
    box-shadow:0 8px 32px rgba(0,0,0,.25);
  }
  body.kiosk-mode #probeEventsPanel h4{
    color:#222;
  }
  body.kiosk-mode #probeEventsPanel li{
    border-bottom:none;
    padding-bottom:2px;
  }
  body.kiosk-mode #probeEventsPanel a{
    color:#007bff;
  }

  /* プローブ用 右側イベント一覧パネル */
  #probeEventsPanel{
    position:fixed;
    width:420px; /* 1行にできるだけ収めるため広めに */
    max-height:60vh;
    overflow:auto;
    background:#fff;
    border-radius:12px;
    box-shadow:0 8px 32px rgba(0,0,0,.25);
    border:1px solid #ddd;
    padding:10px 12px;
    font-size:18px;
    z-index:1300;
    display:none;
  }
  #probeEventsPanel h4{
    margin:0 0 4px;
    font-size:20px;
  }
  #probeEventsPanel ul{
    list-style:none;
    margin:4px 0 0;
    padding-left:0;
  }
  #probeEventsPanel li{
    margin:2px 0;
  }

  /* スマホ向け: 左側イベント列を非表示（操作に直接関係しないため） */
  @media (max-width: 768px) {
    #eventColBg, #events, .eventColBorder { display: none !important; }
    #decades { display: none !important; }
  }

  /* スマホ向け: プローブ用イベント一覧をボトムシート風に */
  @media (max-width: 768px) {
    #probeEventsPanel {
      left: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      top: auto !important;
      width: 100% !important;
      max-width: 100%;
      max-height: 45vh;
      border-radius: 16px 16px 0 0;
      box-shadow: 0 -4px 24px rgba(0,0,0,.2);
    }
    /* キオスク・ステップ3で「診断へ」＋選択数表示中は、その上にパネルを表示 */
    body.kiosk-step3-compact-hint #probeEventsPanel {
      bottom: 88px !important;
    }
  }

  /* スマホ向け: ヘッダー・モーダルをコンパクトに・画面に収める */
  @media (max-width: 768px) {
    html, body { min-height: 100dvh; min-height: 100vh; }
    header { padding: 8px 10px; gap: 6px; }
    header strong { font-size: 1.1em; }
    header .btn, .filters select, .search input { padding: 6px 8px; min-height: 40px; }
    header .chip, .chipCircle { min-width: 40px; min-height: 40px; }
    .search input { min-width: 0; }
    .modal { width: calc(100% - 16px) !important; max-height: 80vh; }
  }

  /* プローブハンドル: タッチでスクロールさせない */
  .handle { touch-action: none; }
</style>
</head>
<body>
  <header>
    <strong style="font-size: 1.5em;">Xnative/Timeline 1.0</strong>
    <div id="repoInfo" style="font-size: 12px; color: #666; margin-left: 12px; display: none;">
      <span id="repoInfoText"></span>
    </div>
    <div class="filters" id="filters">
      <button id="genreFilterBtn" style="padding: 4px 8px; border: 1px solid #ccc; background: #f9f9f9; cursor: pointer; border-radius: 4px;">
        ジャンル選択
      </button>
      <label>重要度
        <select id="filterImp">
          <option value="">すべて</option>
          <option>1</option>
          <option>2</option>
          <option>3</option>
          <option>4</option>
          <option>5</option>
        </select>
      </label>
      <button id="eraBtn" style="padding: 4px 8px; border: 1px solid #ccc; background: #f9f9f9; cursor: pointer; border-radius: 4px;">
        時代区分
      </button>
    </div>
    <div class="search">
      <input id="searchBox" type="text" placeholder="ラベルを検索" />
      <button class="btn" id="searchBtn">検索</button>
      <button class="btn" id="prevBtn">前</button>
      <button class="btn" id="nextBtn">次</button>
    </div>
    <div class="legend">
      <button class="btn" id="settingsBtn" title="設定" style="display:none;">設定</button>
      <button class="btn" id="helpBtn" title="ヘルプ">ヘルプ</button>
      <input type="file" id="fileInput" accept=".csv,.tsv,text/csv,text/tab-separated-values,text/plain" style="display:none" />
      <button class="chip chipCircle" id="toggleRed" aria-pressed="true" title="赤色ラインの表示／非表示" style="display:none;"><span class="dot red"></span></button>
    </div>
  </header>
  <div class="viewport" id="viewport">
    <svg class="stage" id="stage" xmlns="http://www.w3.org/2000/svg">
      <rect x="0" y="0" width="480" height="2600" class="eventColBg" id="eventColBg"/>
      <line x1="480" y1="0" x2="480" y2="2600" class="eventColBorder"/>
      <g id="grid"></g>
      <g id="decades"></g>
      <g id="events"></g>
      <g id="probe-blue"></g>
      <g id="probe-red"></g>
      <text x="12" y="2580" class="editAreaHint">クリックで編集。1950s～2050sまで上下にスクロール可能。</text>
    </svg>
  </div>
  <div id="tooltip" class="tooltip" style="display:none"></div>
  <div id="editor" class="editor" style="display:none"></div>
  <div id="probeEventsPanel"></div>
  <div id="customContextMenu">
    <button type="button" data-action="zoom-in">画面拡大＋</button>
    <button type="button" data-action="zoom-out">画面縮小ー</button>
    <button type="button" data-action="restart">最初からやり直す</button>
  </div>

  <!-- モーダル（ヘルプ＆エラー） -->
  <div id="modal" class="modalOverlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal">
      <header>
        <h3 id="modalTitle">ダイアログ</h3>
      </header>
      <div class="content" id="modalContent"></div>
      <footer id="modalFooter"><button class="btn" id="modalClose">閉じる</button></footer>
    </div>
  </div>

  <script src="config.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
  <!-- 既定の年表JSON（初回ロード時のみ使用）。以降は localStorage を優先。-->
  <script id="events-json" type="application/json">{
    "1952": [{"label":"テレビ放送開始"}],
    "1956": [{"label":"国産初コンピュータ"}],
    "1960": [{"label":"国鉄予約システム"},{"label":"ミステリーゾーン"}],
    "1963": [{"label":"鉄腕アトム"},{"label":"鉄人28号"}],
    "1966": [{"label":"ウルトラQ"},{"label":"サンダーバード"}],
    "1969": [{"label":"住友銀行キャッシュディスペンサ"},{"label":"アポロ11号・月着陸"}],
    "1971": [{"label":"仮面ライダー"}],
    "1973": [{"label":"『8時だョ！全員集合』視聴率50%"}],
    "1977": [{"label":"Apple IIなど初期マイコン"}],
    "1978": [{"label":"マイコン入り製品次々登場"}],
    "1979": [{"label":"機動戦士ガンダム"}],
    "1983": [{"label":"任天堂ファミコン"}],
    "1984": [{"label":"ドラゴンボール"}],
    "1986": [{"label":"PC-9801VM"},{"label":"ビデオレンタル・AVビデオ"}],
    "1995": [{"label":"新世紀エヴァンゲリオン"},{"label":"GHOST IN THE SHELL 攻殻機動隊"}],
    "1996": [{"label":"パソコン通信流行"},{"label":"女子高生にポケベルブーム"},{"label":"たまごっち"},{"label":"ホンダP2"}],
    "1999": [{"label":"iモード・写メール"},{"label":"MATRIX"}],
    "2001": [{"label":"ヤフー！BB開始"}],
    "2005": [{"label":"YouTube"}],
    "2006": [{"label":"『ぐぐる』が流行語大賞"}],
    "2007": [{"label":"電脳コイル"}],
    "2010": [{"label":"iPhoneブレーク"},{"label":"GAFAの影響力拡大"}],
    "2016": [{"label":"DJI Phantom 4／ドローン"}],
    "2018": [{"label":"Ready Player One"}],
    "2020": [{"label":"VR／メタバース注目"}],
    "2022": [{"label":"ChatGPT／生成AI"}],
    "2023": [{"label":"Web3"}]
  </script>

<script>
(function(){
  const vp=document.getElementById('viewport');
  const stage=document.getElementById('stage');
  const customContextMenu=document.getElementById('customContextMenu');
  let pageZoom=1;
  const gridG=document.getElementById('grid');
  const decadesG=document.getElementById('decades');
  const eventsG=document.getElementById('events');
  const editor=document.getElementById('editor');
  const genreFilterBtn=document.getElementById('genreFilterBtn');
  const selImp=document.getElementById('filterImp');
  const searchBox=document.getElementById('searchBox');
  const searchBtn=document.getElementById('searchBtn');
  const prevBtn=document.getElementById('prevBtn');
  const nextBtn=document.getElementById('nextBtn');
  const loadCsvBtn=null;
  const settingsBtn=document.getElementById('settingsBtn');
  (function(){
    const params = new URLSearchParams(window.location.search);
    if (params.get('editmode') === 'ON' && settingsBtn) settingsBtn.style.display = '';
  })();
  const helpBtn=document.getElementById('helpBtn');
  const fileInput=document.getElementById('fileInput');
  const eventColBg=document.getElementById('eventColBg');
  const modal=document.getElementById('modal');
  const modalTitle=document.getElementById('modalTitle');
  const modalContent=document.getElementById('modalContent');
  const modalFooter=document.getElementById('modalFooter');
  const modalClose=document.getElementById('modalClose');

  const YEAR_MIN=1945, YEAR_MAX=2059, AGE_MAX=100;
  const PX_PER_YEAR=22, PX_PER_AGE=25;
  const LEFT_COL_W=480, DECADE_GUTTER=72, ORIGIN_X=LEFT_COL_W, ORIGIN_Y=40;
  const HANDLE_LANE_W=24; // 狭めたドラッグレーン
  const HANDLE_X = ORIGIN_X - HANDLE_LANE_W/2;
  const LABEL_LEFT_X = DECADE_GUTTER + 2;               // ラベル表示開始位置（左）
  const LABEL_RIGHT_X = ORIGIN_X - HANDLE_LANE_W - 8;   // ラベル表示終了（右）
  const width=ORIGIN_X+PX_PER_AGE*(AGE_MAX+2)+200;
  const height=ORIGIN_Y+PX_PER_YEAR*((YEAR_MAX-YEAR_MIN+1)+3);
  stage.setAttribute('width',width); stage.setAttribute('height',height);
  function applyPageZoom(){
    document.body.style.zoom = pageZoom;
  }
  const HANDLE_R = 8; // プローブの〇の半径（直径で余白をとる）
  function applyMobileViewportScroll(){
    if (window.innerWidth <= 768 && vp) {
      const minLeft = LEFT_COL_W - HANDLE_LANE_W - (HANDLE_R * 2);
      vp.scrollLeft = Math.max(minLeft, vp.scrollLeft);
    }
  }
  applyMobileViewportScroll();
  window.addEventListener('resize', applyMobileViewportScroll);
  vp.addEventListener('scroll', ()=>{
    if (window.innerWidth <= 768 && vp) {
      const minLeft = LEFT_COL_W - HANDLE_LANE_W - (HANDLE_R * 2);
      if (vp.scrollLeft < minLeft) vp.scrollLeft = minLeft;
    }
    updateAgeDisplayPosition();
  });
  // クリップパス
  const ns='http://www.w3.org/2000/svg';
  const defs=document.createElementNS(ns,'defs');
  const cpEvents=document.createElementNS(ns,'clipPath'); cpEvents.setAttribute('id','clip-events');
  const cpErect=document.createElementNS(ns,'rect'); cpErect.setAttribute('x', DECADE_GUTTER); cpErect.setAttribute('y', 0); cpErect.setAttribute('width', LEFT_COL_W - DECADE_GUTTER - HANDLE_LANE_W - 4); cpErect.setAttribute('height', height); cpEvents.appendChild(cpErect);
  const cpDec=document.createElementNS(ns,'clipPath'); cpDec.setAttribute('id','clip-decades');
  const cpDrect=document.createElementNS(ns,'rect'); cpDrect.setAttribute('x', 0); cpDrect.setAttribute('y', 0); cpDrect.setAttribute('width', DECADE_GUTTER - 4); cpDrect.setAttribute('height', height); cpDec.appendChild(cpDrect);
  defs.appendChild(cpEvents); defs.appendChild(cpDec); stage.insertBefore(defs, stage.firstChild);
  eventsG.setAttribute('clip-path','url(#clip-events)');
  decadesG.setAttribute('clip-path','url(#clip-decades)');

  // ドラッグ専用レーン（幅24px）を時代で色分け
  function createHandleLaneWithEraColors() {
    const currentDate = new Date();
    const currentYear = currentDate.getFullYear();
    const currentMonth = currentDate.getMonth() + 1; // 0-11 -> 1-12
    const currentDay = currentDate.getDate();
    
    // 令和の現在日付までのY座標を計算
    const reiwaCurrentY = yFromBirthYear(currentYear) + (currentMonth - 1) * (PX_PER_YEAR / 12) + (currentDay - 1) * (PX_PER_YEAR / 365);
    
    // 昭和（1926-1988）
    const showaRect = document.createElementNS(ns, 'rect');
    showaRect.setAttribute('x', ORIGIN_X - HANDLE_LANE_W);
    showaRect.setAttribute('y', yFromBirthYear(1926));
    showaRect.setAttribute('width', HANDLE_LANE_W);
    showaRect.setAttribute('height', yFromBirthYear(1989) - yFromBirthYear(1926));
    showaRect.setAttribute('fill', '#f0f8ff'); // 昭和：淡い青
    stage.insertBefore(showaRect, gridG);
    
    // 平成（1989-2018）
    const heiseiRect = document.createElementNS(ns, 'rect');
    heiseiRect.setAttribute('x', ORIGIN_X - HANDLE_LANE_W);
    heiseiRect.setAttribute('y', yFromBirthYear(1989));
    heiseiRect.setAttribute('width', HANDLE_LANE_W);
    heiseiRect.setAttribute('height', yFromBirthYear(2019) - yFromBirthYear(1989));
    heiseiRect.setAttribute('fill', '#f0fff0'); // 平成：淡い緑
    stage.insertBefore(heiseiRect, gridG);
    
    // 令和（2019-現在）
    const reiwaRect = document.createElementNS(ns, 'rect');
    reiwaRect.setAttribute('x', ORIGIN_X - HANDLE_LANE_W);
    reiwaRect.setAttribute('y', yFromBirthYear(2019));
    reiwaRect.setAttribute('width', HANDLE_LANE_W);
    reiwaRect.setAttribute('height', reiwaCurrentY - yFromBirthYear(2019));
    reiwaRect.setAttribute('fill', '#fff0f0'); // 令和：淡い赤
    stage.insertBefore(reiwaRect, gridG);
    
    // 令和の現在日付以降は白
    if (currentYear < YEAR_MAX) {
      const reiwaFutureRect = document.createElementNS(ns, 'rect');
      reiwaFutureRect.setAttribute('x', ORIGIN_X - HANDLE_LANE_W);
      reiwaFutureRect.setAttribute('y', reiwaCurrentY);
      reiwaFutureRect.setAttribute('width', HANDLE_LANE_W);
      reiwaFutureRect.setAttribute('height', yFromBirthYear(YEAR_MAX + 1) - reiwaCurrentY);
      reiwaFutureRect.setAttribute('fill', '#ffffff'); // 未来：白
      stage.insertBefore(reiwaFutureRect, gridG);
    }
    
    // 境界線
    const laneBorder = document.createElementNS(ns, 'line');
  laneBorder.setAttribute('x1', ORIGIN_X - HANDLE_LANE_W);
  laneBorder.setAttribute('x2', ORIGIN_X - HANDLE_LANE_W);
  laneBorder.setAttribute('y1', 0);
  laneBorder.setAttribute('y2', height);
    laneBorder.setAttribute('class', 'handleLaneBorder');
  stage.insertBefore(laneBorder, gridG);
  }
  
  createHandleLaneWithEraColors();

  function yFromBirthYear(by){return ORIGIN_Y+(by-YEAR_MIN)*PX_PER_YEAR;}
  function xFromAge(age){return ORIGIN_X+age*PX_PER_AGE;}
  function lineEl(x1,y1,x2,y2,cls){let l=document.createElementNS('http://www.w3.org/2000/svg','line');l.setAttribute('x1',x1);l.setAttribute('y1',y1);l.setAttribute('x2',x2);l.setAttribute('y2',y2);if(cls) l.setAttribute('class',cls);return l;}
  function textEl(txt,x,y,cls){let t=document.createElementNS('http://www.w3.org/2000/svg','text');t.textContent=txt;t.setAttribute('x',x);t.setAttribute('y',y);if(cls) t.setAttribute('class',cls);return t;}
  function circleEl(cx,cy,r,cls){let c=document.createElementNS('http://www.w3.org/2000/svg','circle');c.setAttribute('cx',cx);c.setAttribute('cy',cy);c.setAttribute('r',r);if(cls)c.setAttribute('class',cls);return c;}

  // ===== モーダル（共通） =====
  function openModal(title, html, options){
    const prevFocus = document.activeElement;
    modalTitle.textContent = title;
    modalContent.innerHTML = html;
    modal.setAttribute('aria-hidden','false');
    modal.style.display = 'flex';
    modal.dataset.prevFocusId = prevFocus && prevFocus.id ? prevFocus.id : '';
    const modalBox = modal.querySelector('.modal');
    if (modalBox) {
      modalBox.scrollTop = 0;
      requestAnimationFrame(() => { modalBox.scrollTop = 0; });
    }
    const footerMode = (options && options.footer) || 'default';
    if (modalFooter) {
      if (footerMode === 'none') {
        modalFooter.style.display = 'none';
      } else {
        modalFooter.style.display = 'flex';
        modalClose.textContent = footerMode === 'next' ? '次へ' : '閉じる';
        modalClose.classList.toggle('btn-primary', footerMode === 'next');
      }
    }
    modalClose.focus();
  }
  function openModalText(title, text){
    const prevFocus = document.activeElement;
    modalTitle.textContent = title;
    modalContent.textContent = text;
    modal.setAttribute('aria-hidden','false');
    modal.style.display = 'flex';
    modal.dataset.prevFocusId = prevFocus && prevFocus.id ? prevFocus.id : '';
    const modalBox = modal.querySelector('.modal');
    if (modalBox) {
      modalBox.scrollTop = 0;
      requestAnimationFrame(() => { modalBox.scrollTop = 0; });
    }
    modalClose.focus();
  }
  function closeModal(){
    const id = modal.dataset.prevFocusId;
    if(id){ const el = document.getElementById(id); if(el) el.focus(); }
    modal.setAttribute('aria-hidden','true');
    modal.style.display='none';
    if (modalFooter) { modalFooter.style.display = 'flex'; }
    modalClose.textContent = '閉じる';
    modalClose.classList.remove('btn-primary');
    // キオスク用のモーダル遷移
    if (window.kioskMode && kioskModalPhase) {
      const phase = kioskModalPhase;
      kioskModalPhase = null;
      if (phase === 'diag') {
        if (typeof showKioskOverallResult === 'function') {
          // プロンプト2が設定されている場合のみ、2回目のAI呼び出し用に診断中スピナーを表示
          try {
            const cfr = getCfrPrompts();
            const secondHead = (cfr.secondPromptHead || DEFAULT_CFR_PROMPTS.secondPromptHead || '').trim();
            if (secondHead) {
              const loadingHtml = '<div class="kiosk-diagnosing"><div class="spinner"></div><p>AIで追加のおすすめを生成しています。<br>しばらくお待ちください。</p></div>';
              openModal('診断中', loadingHtml, { footer: 'none' });
            }
          } catch (_) {}
          showKioskOverallResult();
        }
      } else if (phase === 'overall') {
        if (typeof showKioskUsageScreen === 'function') {
          showKioskUsageScreen();
        }
      } else if (phase === 'usage') {
        if (typeof resetKioskToStart === 'function') {
          resetKioskToStart();
        }
      }
    }
  }
  modalClose.addEventListener('click', closeModal);
  modal.addEventListener('click', (e)=>{ if(e.target===modal) closeModal(); });
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && modal.style.display==='flex') closeModal(); });
  function showError(title, errors){
    const text = Array.isArray(errors) ? errors.join('\n') : String(errors||'');
    openModalText(title, text);
  }
  function showInfo(title, html){ openModal(title, html); }

  // ===== 検索ハイライトの状態 =====
  let matches=[]; let matchIndex=-1; let hlRect=null; let hlTarget=null; let clearOnNextMove=false;
  function clearHighlight(soft){ if(hlRect && hlRect.parentNode) hlRect.parentNode.removeChild(hlRect); if(hlTarget) hlTarget.classList.remove('hlText'); hlRect=null; hlTarget=null; if(!soft){ clearOnNextMove=false; } }
  function highlight(el){
    clearHighlight(true);
    const bbox=el.getBBox();
    hlRect=document.createElementNS(ns,'rect');
    const padX=6, padY=3;
    hlRect.setAttribute('x', bbox.x - padX); hlRect.setAttribute('y', bbox.y - padY);
    hlRect.setAttribute('width', bbox.width + padX*2); hlRect.setAttribute('height', bbox.height + padY*2);
    hlRect.setAttribute('rx', 4); hlRect.setAttribute('fill', '#000');
    eventsG.insertBefore(hlRect, el);
    el.classList.add('hlText'); hlTarget=el;
    const r=el.getBoundingClientRect(); const rv=vp.getBoundingClientRect();
    if(r.top < rv.top || r.bottom > rv.bottom){ vp.scrollTop += (r.top - rv.top) - 80; }
    clearOnNextMove=true;
    // 検索ヒット時: 下の〇をその年にセット（PC/スマホ共通）。スマホは下の〇がヘッダ2年分下に来るようスクロール
    const yearAttr = el.getAttribute('data-year');
    if (yearAttr != null && yearAttr !== '') {
      const year = parseInt(yearAttr, 10);
      if (!isNaN(year) && typeof probeBlue !== 'undefined') {
        probeBlue.eventYear = Math.max(YEAR_MIN, Math.min(YEAR_MAX, year));
        probeBlue.redraw();
        if (typeof window.updateProbeEventsPanel === 'function') window.updateProbeEventsPanel(probeBlue.eventYear);
        if (window.matchMedia('(max-width: 768px)').matches && typeof window.scrollProbeEventYearIntoView === 'function') {
          window.scrollProbeEventYearIntoView();
        }
      }
    }
  }

  // ===== JSONロード/セーブ =====
  const LS_KEYS=['timelineEventsV2','timelineEventsV1'];
  // ===== ジャンル（デフォルト値。GitHub JSONの genres により上書き可能） =====
  let GENRES=['ANI','MAN','GAM','TVP','MOV','NET','HAR','PHE','SOF','TOY','FAS','BOO','MAG','NOV','MUS','IDL','RDO','EVT','FMT','SPW','RDE','FOO','UNC'];
  let GENRE_LABELS={
    'ANI':'アニメ','MAN':'マンガ','GAM':'ゲーム','TVP':'テレビ番組',
    'MOV':'映画','NET':'インターネット','HAR':'ハードウェア','PHE':'現象・流行',
    'SOF':'ソフトウェア','TOY':'おもちゃ','FAS':'ファッション','BOO':'書籍',
    'MAG':'雑誌','NOV':'小説','MUS':'音楽','IDL':'アイドル','RDO':'ラジオ',
    'EVT':'イベント','FMT':'フォーマット','SPW':'スポーツ','RDE':'テーマパーク',
    'FOO':'食','UNC':'その他'
  };
  let GENRE_SET=new Set(GENRES);
  function setGenresFromRemote(genresDef){
    try{
      if(Array.isArray(genresDef) && genresDef.length){
        // 期待フォーマット: [{code:'ANI', label:'アニメ'}, ...]
        const codes=[]; const labels={};
        for(const g of genresDef){
          const code=String(g.code||'').toUpperCase();
          if(!code) continue;
          codes.push(code);
          labels[code]=g.label||code;
        }
        if(codes.length){ GENRES=codes; GENRE_LABELS=labels; GENRE_SET=new Set(GENRES); }
      } else if(genresDef && genresDef.list && Array.isArray(genresDef.list)){
        // 互換フォーマット: {list:['ANI',...], labels:{ANI:'アニメ',...}}
        const codes=genresDef.list.map(c=>String(c).toUpperCase());
        const labels={...genresDef.labels};
        if(codes.length){ GENRES=codes; GENRE_LABELS=labels||GENRE_LABELS; GENRE_SET=new Set(GENRES); }
      }
    }catch(e){ console.warn('ジャンル定義の適用に失敗:', e); }
  }
  function getGenreKey(genre){
    if(Array.isArray(genre)) return genre.map(g=>String(g).toUpperCase()).sort().join('・');
    return String(genre||'').toUpperCase();
  }
  function itemHasSelectedGenre(item){
    // 選択なしは true（後段で空集合扱いの箇所は別途制御）
    if(selectedGenres.size===0) return true;
    const g=item.genre;
    if(Array.isArray(g)) return g.some(code=>selectedGenres.has(String(code).toUpperCase()));
    const code=String(g||'UNC').toUpperCase();
    return selectedGenres.has(code);
  }
  function normalizeItem(it){
    if(typeof it==='string') return {label: it};
    const o={ label: it.label||'' };
    if(it.startYear!==undefined && it.startYear!==null && String(it.startYear)!==''){
      const n = parseInt(it.startYear,10);
      if(n>=YEAR_MIN && n<=YEAR_MAX) o.startYear=n; else o.startYear='';
    }
    if(it.endYear!==undefined && it.endYear!==null && String(it.endYear)!==''){
      if(String(it.endYear).toLowerCase() === 'ongoing') {
        o.endYear = 'ongoing';
      } else {
        const n = parseInt(it.endYear,10);
        if(n>=YEAR_MIN && n<=YEAR_MAX) o.endYear=n; else o.endYear='';
      }
    }
    if(it.genre) {
      if(Array.isArray(it.genre)) {
        o.genre = it.genre.map(g => String(g).toUpperCase());
      } else {
        const genres = String(it.genre).split('・').map(g => g.trim().toUpperCase());
        o.genre = genres.length > 0 ? genres : [String(it.genre).toUpperCase()];
      }
    }
    if(it.imp!==undefined && it.imp!==null && String(it.imp)!==''){
      const n = parseInt(it.imp,10);
      if(n>=1 && n<=5) o.imp=n; else o.imp='';
    }
    if(it.url) o.url = it.url;
    // 英語名・英語URL があればそのまま保持（オプション）
    if(it.label_en) o.label_en = it.label_en;
    else if(it.enLabel) o.label_en = it.enLabel;
    // URL_en / url_en / URL_e / urlEn などをすべて url_e に正規化
    if(it.url_e) o.url_e = it.url_e;
    else if(it.url_en) o.url_e = it.url_en;
    else if(it.URL_en) o.url_e = it.URL_en;
    else if(it.URL_e) o.url_e = it.URL_e;
    else if(it.urlEn) o.url_e = it.urlEn;
    if(it.note) o.note = it.note;
    if(it.deleted !== undefined) o.deleted = it.deleted;
    return o;
  }
  function normalizeAll(obj){ const out={}; for(const y of Object.keys(obj)){ const arr = Array.isArray(obj[y])? obj[y] : []; out[y] = arr.map(normalizeItem).filter(it=>it.label); } return out; }
  function loadEvents(){ 
    for(const k of LS_KEYS){ 
      try{ 
        const s=localStorage.getItem(k); 
        if(s){ 
          const data = JSON.parse(s);
          if (data.events) {
            // 新しい形式（events + eraSettings）
            eraSettings = data.eraSettings || [];
            if (data.genres) { setGenresFromRemote(data.genres); }
            console.log('loadEvents: eraSettings読み込み:', eraSettings);
            return normalizeAll(data.events);
          } else {
            // 古い形式（eventsのみ）
            console.log('loadEvents: 古い形式のデータ');
            return normalizeAll(data);
          }
        } 
      }catch(e){} 
    } 
    try{ 
      const txt=document.getElementById('events-json').textContent.trim(); 
      const embedded=JSON.parse(txt);
      // 埋め込みJSONにも genres があれば使用
      if (embedded.genres) { setGenresFromRemote(embedded.genres); }
      return normalizeAll(embedded.events ? embedded.events : embedded); 
    } catch(e){ 
      console.error('embedded JSON parse failed', e); 
      return {}; 
    } 
  }
  // 編集フラグを管理するオブジェクト
  let editFlags = {};
  
  
  // データ鮮度時刻（GitHub上のjsonのタイムスタンプ）
  let dataFreshnessTimestamp = null;
  
  // ラベルバックアップ（編集前のデータ）
  let labelBackups = {};
  
  // 物理削除用の削除記録（CSV出力のために保持）
  let deletionRecords = [];
  
  // 順番変更フラグ
  let orderChanged = false;
  
  // 編集フラグを保存
  function saveEditFlags() {
    localStorage.setItem('xnative_edit_flags', JSON.stringify(editFlags));
  }
  
  // 編集フラグを読み込み
  function loadEditFlags() {
    const saved = localStorage.getItem('xnative_edit_flags');
    if (saved) {
      editFlags = JSON.parse(saved);
    }
  }
  
  
  // データ鮮度時刻を保存
  function saveDataFreshnessTimestamp() {
    localStorage.setItem('xnative_data_freshness', JSON.stringify(dataFreshnessTimestamp));
  }
  
  // データ鮮度時刻を読み込み
  function loadDataFreshnessTimestamp() {
    const saved = localStorage.getItem('xnative_data_freshness');
    if (saved) {
      dataFreshnessTimestamp = JSON.parse(saved);
    }
  }
  
  // ラベルバックアップを保存
  function saveLabelBackups() {
    localStorage.setItem('xnative_label_backups', JSON.stringify(labelBackups));
  }
  
  // ラベルバックアップを読み込み
  function loadLabelBackups() {
    const saved = localStorage.getItem('xnative_label_backups');
    if (saved) {
      labelBackups = JSON.parse(saved);
    }
  }
  
  // 項目の編集フラグを設定
  function setEditFlag(year, label, genre) {
    const key = `${year}|${label}|${genre || ''}`;
    editFlags[key] = true;
    saveEditFlags();
    console.log('編集フラグを設定:', key);
  }
  
  // 項目の編集フラグをチェック
  function hasEditFlag(year, label, genre) {
    const key = `${year}|${label}|${genre || ''}`;
    return editFlags[key] === true;
  }
  
  // 編集フラグをクリア
  function clearEditFlags() {
    editFlags = {};
    saveEditFlags();
    console.log('編集フラグをクリアしました');
  }
  
  
  // ラベルバックアップを設定
  function setLabelBackup(year, label, genre, backupData) {
    const key = `${year}|${label}|${genre || ''}`;
    labelBackups[key] = backupData;
    saveLabelBackups();
    console.log('ラベルバックアップを設定:', key, backupData);
  }
  
  // ラベルバックアップを取得
  function getLabelBackup(year, label, genre) {
    const key = `${year}|${label}|${genre || ''}`;
    return labelBackups[key];
  }
  
  // ラベルバックアップをクリア
  function clearLabelBackups() {
    labelBackups = {};
    saveLabelBackups();
    console.log('ラベルバックアップをクリアしました');
  }

  // 削除記録の保存/読込/追加/クリア
  function saveDeletionRecords(){
    localStorage.setItem('xnative_deletions', JSON.stringify(deletionRecords));
  }
  function loadDeletionRecords(){
    try{
      const s = localStorage.getItem('xnative_deletions');
      deletionRecords = s ? JSON.parse(s) : [];
    }catch(e){ deletionRecords = []; }
  }
  function addDeletionRecord(year, item){
    if(!item) return;
    const genreKey = Array.isArray(item.genre) ? item.genre.slice().sort().join('・') : (item.genre || '');
    const rec = {
      year: Number(item.startYear || year || ''),
      startYear: item.startYear || year || '',
      endYear: item.endYear || '',
      label: item.label || '',
      genre: genreKey,
      deleted: true,
      imp: item.imp || '',
      url: item.url || '',
      note: item.note || ''
    };
    deletionRecords.push(rec);
    saveDeletionRecords();
  }
  function clearDeletionRecords(){
    deletionRecords = [];
    saveDeletionRecords();
  }

  // tombstone（削除記録）チェック
  function _genreKey(genre){
    if(Array.isArray(genre)) return genre.slice().map(g=>String(g).toUpperCase()).sort().join('・');
    return String(genre||'').toUpperCase();
  }
  function isLocallyDeleted(year, label, genre){
    const key = `${String(label||'')}|${_genreKey(genre)}`;
    for(const rec of (deletionRecords||[])){
      const rKey = `${String(rec.label||'')}|${_genreKey(rec.genre)}`;
      if(Number(rec.year)===Number(year) && rKey===key) return true;
    }
    return false;
  }
  
  // データ鮮度時刻を設定
  function setDataFreshnessTimestamp(timestamp) {
    dataFreshnessTimestamp = timestamp;
    saveDataFreshnessTimestamp();
    console.log('データ鮮度時刻を設定:', timestamp);
  }
  
  // データ鮮度時刻を取得
  function getDataFreshnessTimestamp() {
    return dataFreshnessTimestamp;
  }
  
  // 順番変更フラグを設定
  function setOrderChanged(flag) {
    orderChanged = flag;
    console.log('順番変更フラグを設定:', flag);
  }
  
  // 順番変更フラグを取得
  function getOrderChanged() {
    return orderChanged;
  }
  
  // 要注意モードかどうかを判定
  function isCautionMode(remoteTimestamp) {
    const localTimestamp = getDataFreshnessTimestamp();
    if (!localTimestamp || !remoteTimestamp) {
      return false;
    }
    
    const localDate = new Date(localTimestamp);
    const remoteDate = new Date(remoteTimestamp);
    
    return remoteDate > localDate;
  }
  
  // 通常モードでの同期処理
  function performNormalModeSync(localData, remoteData) {
    console.log('通常モードでの同期を実行');
    
    // 常にリモートの順序を採用
    console.log('リモートの順序を採用');
    
    // 編集フラグが立っている項目のみローカルを保持、それ以外はリモートを採用
    const merged = {};
    
    for (const [year, localItems] of Object.entries(localData)) {
      const remoteItems = remoteData[year] || [];
      const mergedItems = [];
      const localItemMap = new Map();
      
      // ローカルアイテムをマップ化
      localItems.forEach(item => {
        const key = `${item.label}|${item.genre || ''}`;
        localItemMap.set(key, item);
      });
      
      // リモートの順序に従って処理
      remoteItems.forEach(remoteItem => {
        const key = `${remoteItem.label}|${remoteItem.genre || ''}`;
        const localItem = localItemMap.get(key);
        const hasLocalEdit = localItem ? hasEditFlag(year, localItem.label, localItem.genre) : false;
        const hasLocalDelete = localItem ? localItem.deleted === true : false;
        const deletedByTombstone = isLocallyDeleted(year, remoteItem.label, remoteItem.genre);
        
        if (deletedByTombstone) {
          return; // tombstoneがあるので採用しない
        } else if (hasLocalEdit || hasLocalDelete) {
          // 削除フラグが立っている場合は結果に含めない（リモート項目を削除扱い）
          if (hasLocalDelete) {
            return; // skip
          }
          // 編集フラグが立っている場合はローカルを採用
          mergedItems.push(localItem);
        } else {
          // 編集フラグも削除フラグも立っていない場合はリモートを採用
          mergedItems.push(remoteItem);
        }
      });
      
      // ローカルのみに存在するアイテムを追加（tombstoneは除外）
      for (const [key, localItem] of localItemMap) {
        const existsInRemote = remoteItems.some(remoteItem => {
          const remoteKey = `${remoteItem.label}|${remoteItem.genre || ''}`;
          return remoteKey === key;
        });
        
        if (!existsInRemote) {
          if (localItem && (localItem.deleted === true || isLocallyDeleted(year, localItem.label, localItem.genre))) continue;
          mergedItems.push(localItem);
        }
      }
      
      // リモートのみに存在するアイテムを追加
      remoteItems.forEach(remoteItem => {
        const key = `${remoteItem.label}|${remoteItem.genre || ''}`;
        const existsInLocal = localItemMap.has(key);
        
        if (!existsInLocal) {
          mergedItems.push(remoteItem);
        }
      });
      
      // 念のため削除フラグのものを除去
      merged[year] = mergedItems.filter(it => it && it.deleted !== true);
    }
    
    return { merged, conflicts: [] };
  }
  
  // 要注意モードでの同期処理
  function performCautionModeSync(localData, remoteData) {
    console.log('要注意モードでの同期を実行');
    
    const conflicts = [];
    const merged = {};
    
    for (const [year, localItems] of Object.entries(localData)) {
      const remoteItems = remoteData[year] || [];
      const mergedItems = [];
      const localItemMap = new Map();
      
      // ローカルアイテムをマップ化
      localItems.forEach(item => {
        const key = `${item.label}|${item.genre || ''}`;
        localItemMap.set(key, item);
      });
      
      // リモートの順序に従って処理
      remoteItems.forEach(remoteItem => {
        const key = `${remoteItem.label}|${remoteItem.genre || ''}`;
        const localItem = localItemMap.get(key);
        const hasLocalEdit = localItem ? hasEditFlag(year, localItem.label, localItem.genre) : false;
        const hasLocalDelete = localItem ? localItem.deleted === true : false;
        const deletedByTombstone = isLocallyDeleted(year, remoteItem.label, remoteItem.genre);
        
        if (deletedByTombstone) {
          return; // tombstoneにより削除
        } else if (hasLocalEdit || hasLocalDelete) {
          if (hasLocalDelete) {
            // 削除は結果に含めない
            return;
          } else if (hasLocalEdit) {
            // 編集フラグが立っている場合は競合チェック
            const backup = getLabelBackup(year, localItem.label, localItem.genre);
            if (backup && JSON.stringify(backup) === JSON.stringify(remoteItem)) {
              // バックアップとリモートが同じ場合はローカルの編集を採用（リモートの順序で配置）
              mergedItems.push(localItem);
            } else {
              // バックアップとリモートが異なる場合は競合エラー
              conflicts.push({
                year: year,
                label: localItem.label,
                genre: localItem.genre || '',
                localItem: localItem,
                remoteItem: remoteItem,
                conflictFields: [{ field: 'content', localValue: localItem, remoteValue: remoteItem }]
              });
              // 競合の場合はリモートの内容を採用
              mergedItems.push(remoteItem);
            }
          }
        } else {
          // 編集フラグも削除フラグも立っていない場合はリモートを採用
          mergedItems.push(remoteItem);
        }
      });
      
      // ローカルのみに存在するアイテムを追加
      for (const [key, localItem] of localItemMap) {
        const existsInRemote = remoteItems.some(remoteItem => {
          const remoteKey = `${remoteItem.label}|${remoteItem.genre || ''}`;
          return remoteKey === key;
        });
        
        if (!existsInRemote) {
          if (localItem && (localItem.deleted === true || isLocallyDeleted(year, localItem.label, localItem.genre))) continue;
          mergedItems.push(localItem);
        }
      }
      // tombstone除外
      merged[year] = mergedItems.filter(it => it && it.deleted !== true);
    }
    
    return { merged, conflicts };
  }

  function saveEvents(){ 
    try{ 
      const data = {
        events: events,
        eraSettings: eraSettings,
        genres: GENRES.map(code=>({code, label: (GENRE_LABELS && GENRE_LABELS[code]) ? GENRE_LABELS[code] : code}))
      };
      
      // 削除フラグ付きの項目をチェック
      let deletedItems = [];
      for (const year of Object.keys(events)) {
        const items = events[year] || [];
        for (const item of items) {
          if (item.deleted === true) {
            deletedItems.push({ year, label: item.label, deleted: item.deleted });
          }
        }
      }
      
      console.log('saveEvents: ローカルストレージに保存', {
        hasEvents: !!data.events,
        hasEraSettings: !!data.eraSettings,
        eraSettingsLength: data.eraSettings.length,
        deletedItemsCount: deletedItems.length,
        deletedItems: deletedItems
      });
      localStorage.setItem('timelineEventsV2', JSON.stringify(data)); 
    }catch(e){
      console.error('saveEvents エラー:', e);
    } 
  }

  // ===== 時代区分 ====
  let eraSettings = []; // 時代区分の設定データ

  // ===== GitHub同期機能 =====
  let githubConfig = {
    accessToken: '',
    owner: 'hortense667',
    repo: 'xnative',
    filePath: 'timeline_popculture_02.json'
  };

  // ===== CFR プロンプト設定 =====
  const DEFAULT_CFR_PROMPTS = {
    temperature: 0.9,
    topTitle: 'Xnative/Timeline メディアスタック・クロノロジー診断テスト',
    topDescription: 'あなたが特に好きだった、影響を受けたコンテンツ（マンガ・アニメ・ゲーム、本、音楽、映画など）、愛するほど使い込んだ、衝撃を受けたハードウェアやソフトウェア（楽器、カメラ、コンピューター、ウェブサイトなど）、体に染み込んだライスタイルや文化（食、イベントなど）を選んでいくことで、あなたの「ネイティブ」な感性を診断します。',
    eventChecklistDescription: 'チェックが終わったら画面右下の「診断」を選んでください。',
    geminiPromptHead: '【役割】 あなたはポップカルチャーの変遷に精通したジョーク作家です。提示されるデータから、誰もが簡単には気づかないような視点からその人物の感性をまったく新た表現で面白く言い換えてください。\n【タスク】 以下のアンケート結果に基づき、対象者の感性を分析してて診断した対象に語りかけてください。\n生年・性別から各コンテンツに触れた時期（幼少期〜成人）を特定する。コンテンツや製品を羅列した説明は不要。\nその当時の社会情勢や技術的背景（時代背景）を分析に組み込む。\n最後に一行空白をおいて「あなたは●●●型ネイティブです」という一文で締めくくる。\n【厳守すべき制約】\n形式: 箇条書きやリスト形式、見出し、ハッシュタグは一切使用禁止です。\n構成: 全体を**「単一の段落」または「接続詞でつながれた一続きの散文」**として構成してください。\n文字数: 合計で300文字以内を厳守してください。 冗長な修飾語を省き、情報の密度を高めること。\n禁止事項: 「承知いたしました」「分析結果を述べます」などの前置きや、末尾の補足説明は一切不要です。分析本文のみを出力してください。\n\n【データ】\n\n',
    overallTitle: '総合結果',
    overallDescription: 'ここに「総合結果（ダミー）」を表示します。実際の実装では、複数人分の傾向や集計結果などを表示する予定です。',
    secondPromptHead: '',
    usageTitle: '使いかた映像（ダミー）',
    usageDescription: 'ここでは「HARC の紹介」と「Xnative Timeline の紹介」の映像が流れます（ダミー画面）。しばらくご覧いただいたあと、下の「スタート」ボタンで最初の画面に戻ります。'
  };
  let cfrPromptsConfig = null;   // cfr_prompts.json 全体
  let activeCfrPrompts = null;   // 現在の年表ファイルに対応する設定

  async function loadCfrPromptsFromGitHub() {
    try {
      const owner = githubConfig.owner || 'hortense667';
      const repo  = githubConfig.repo  || 'xnative';
      const path  = 'cfr_prompts.json';
      const rawUrl = `https://raw.githubusercontent.com/${owner}/${repo}/main/${path}`;
      const res = await fetch(rawUrl);
      if (!res.ok) {
        console.warn('cfr_prompts.json の取得に失敗しました:', res.status);
        return null;
      }
      const json = await res.json();
      return json;
    } catch (e) {
      console.warn('cfr_prompts.json の読み込みエラー:', e);
      return null;
    }
  }

  function selectActiveCfrPrompts() {
    const cfg = cfrPromptsConfig || {};
    const byFilePath = cfg.byFilePath || {};
    const filePath = githubConfig.filePath || '';
    if (filePath && byFilePath[filePath]) {
      return byFilePath[filePath];
    }
    const base = filePath.split('/').pop();
    if (base) {
      for (const key in byFilePath) {
        if (Object.prototype.hasOwnProperty.call(byFilePath, key)) {
          const kBase = String(key).split('/').pop();
          if (kBase === base) return byFilePath[key];
        }
      }
    }
    return cfg.default || DEFAULT_CFR_PROMPTS;
  }

  function getCfrPrompts() {
    return activeCfrPrompts || DEFAULT_CFR_PROMPTS;
  }

  async function ensureCfrPromptsLoaded() {
    if (activeCfrPrompts) return;
    if (!cfrPromptsConfig) {
      cfrPromptsConfig = await loadCfrPromptsFromGitHub();
    }
    activeCfrPrompts = selectActiveCfrPrompts();
  }

  // 初期化時にリモートからデータを読み込み
  let events = {};
  
  // 編集フラグを読み込み
  loadEditFlags();
  
  
  // データ鮮度時刻を読み込み
  loadDataFreshnessTimestamp();
  
  // ラベルバックアップを読み込み
  loadLabelBackups();
  
  // 時代区分データを読み込み（loadEventsで既に読み込まれている場合は上書きしない）
  if (!eraSettings || eraSettings.length === 0) {
    eraSettings = loadEraSettings();
  }
  
  // URLパラメータからリポジトリ情報を取得する関数
  function getUrlParams() {
    const urlParams = new URLSearchParams(window.location.search);
    return {
      owner: urlParams.get('owner'),
      repo: urlParams.get('repo'),
      filePath: urlParams.get('filePath') || urlParams.get('path')
    };
  }

  // URLパラメータでGitHub設定を更新
  function updateGitHubConfigFromUrl() {
    const urlParams = getUrlParams();
    let configUpdated = false;

    if (urlParams.owner) {
      githubConfig.owner = urlParams.owner;
      configUpdated = true;
    }
    if (urlParams.repo) {
      githubConfig.repo = urlParams.repo;
      configUpdated = true;
    }
    if (urlParams.filePath) {
      githubConfig.filePath = urlParams.filePath;
      configUpdated = true;
    }

    if (configUpdated) {
      saveGitHubConfig();
      console.log('URLパラメータからGitHub設定を更新:', githubConfig);
      // URLの整合性も保つ（owner/repo/filePath の現在値を反映）
      try{
        const params = new URLSearchParams(window.location.search);
        if(githubConfig.owner) params.set('owner', githubConfig.owner); else params.delete('owner');
        if(githubConfig.repo) params.set('repo', githubConfig.repo); else params.delete('repo');
        if(githubConfig.filePath) params.set('filePath', githubConfig.filePath); else params.delete('filePath');
        const newUrl = `${window.location.pathname}?${params.toString()}`;
        window.history.replaceState(null, '', newUrl);
      }catch(e){ console.warn('URL更新に失敗:', e); }
    }
  }

  // リポジトリ情報をヘッダーに表示
  function updateRepoInfoDisplay() {
    const repoInfoDiv = document.getElementById('repoInfo');
    const repoInfoText = document.getElementById('repoInfoText');
    
    if (repoInfoDiv && repoInfoText) {
      const urlParams = getUrlParams();
      
      // URLパラメータが指定されている場合は表示
      repoInfoDiv.style.display = 'none';
    }
  }

  // GitHub設定を読み込み（initializeWithRemoteDataの前に実行）
  loadGitHubConfig();
  
  // URLパラメータでGitHub設定を更新
  updateGitHubConfigFromUrl();
  
  // リポジトリ情報の表示を更新
  updateRepoInfoDisplay();
  
  // 初期化時にリモートからデータを読み込み
  async function initializeWithRemoteData() {
    console.log('初期化: リモートからデータを読み込み開始');
    
    try {
      // GitHubから読み込みを試行
      const remoteData = await loadFromGitHubWithoutToken();
      if (remoteData !== null && remoteData !== undefined) {
        events = remoteData;
        saveEvents();
        renderEvents();
        console.log('初期化: GitHubからデータ読み込み成功');
        // CFR プロンプト設定も同じリポジトリから読み込む
        cfrPromptsConfig = await loadCfrPromptsFromGitHub();
        activeCfrPrompts = selectActiveCfrPrompts();
        return;
      } else {
        throw new Error('GitHubからデータを取得できませんでした');
      }
    } catch (e) {
      console.error('初期化: GitHubからの読み込み失敗:', e.message);
      showError('初期化エラー', `GitHubからのデータ読み込みに失敗しました: ${e.message}`);
      return;
    }
  }
  
  // 初期化実行
  initializeWithRemoteData();
  
  // 自動保存の基準を初期化
  let lastSavedEventsData = JSON.stringify(events);

  // ===== フィルタ =====
  let filterGenre = '';
  let filterImp   = '';
  let selectedGenres = new Set(); // 選択されたジャンルのセット
  
  // 時代区分データの読み込み
  function loadEraSettings() {
    const saved = localStorage.getItem('eraSettings');
    return saved ? JSON.parse(saved) : [];
  }
  
  // 時代区分データの保存
  function saveEraSettings() {
    const newEraSettings = [];
    const nameInputs = document.querySelectorAll('[id^="eraName"]');
    
    nameInputs.forEach(nameInput => {
      const name = nameInput.value.trim();
      if (name) {
        const index = nameInput.id.replace('eraName', '');

        const enabled = document.getElementById(`eraEnabled${index}`)?.checked ?? true;
        const fillEnabled = document.getElementById(`eraFill${index}`)?.checked ?? true;
        const startYearStr = document.getElementById(`eraStart${index}`)?.value.trim();
        const endYearStr = document.getElementById(`eraEnd${index}`)?.value.trim();
        const endOngoing = document.getElementById(`eraEndOngoing${index}`)?.checked ?? false;
        const color = document.getElementById(`eraColor${index}`)?.value || '#4169E1';
        const opacity = document.getElementById(`eraOpacity${index}`)?.value || '0.3';
        
        const startYear = startYearStr ? parseInt(startYearStr, 10) : '';
        let endYear = endYearStr ? parseInt(endYearStr, 10) : '';
        if (endOngoing) {
          endYear = 'ongoing';
        }

        newEraSettings.push({
          name,
          startYear,
          endYear,
          color,
          opacity,
          enabled,
          fillEnabled
        });
      }
    });

    eraSettings = newEraSettings;
    
    try {
      const data = {
        events: events,
        eraSettings: eraSettings
      };
      localStorage.setItem('timelineEventsV2', JSON.stringify(data));
    } catch (e) {
      console.error('ローカルストレージ保存エラー:', e);
    }
    
    closeModal();
    renderEraBackgrounds();
  }
  
  // 初期化（loadEvents内でeraSettingsが設定されるため、ここでは初期化しない）
  
  // 時代区分設定ポップアップの表示
  function showEraSettingsModal() {
    closeModal();
    const colorOptions = [
      { value: '#4169E1', label: '青' }, { value: '#32CD32', label: '緑' },
      { value: '#DC143C', label: '赤' }, { value: '#FF8C00', label: 'オレンジ' },
      { value: '#8A2BE2', label: '紫' }, { value: '#00CED1', label: '水色' },
      { value: '#FFD700', label: '黄' }, { value: '#696969', label: 'グレー' }
    ];
    const opacityOptions = [
      { value: '0.1', label: '10%' }, { value: '0.2', label: '20%' },
      { value: '0.3', label: '30%' }, { value: '0.4', label: '40%' },
      { value: '0.5', label: '50%' }, { value: '0.6', label: '60%' },
      { value: '0.7', label: '70%' }, { value: '0.8', label: '80%' }
    ];

    const eraItems = eraSettings.map((era, index) => {
      const colorOptionsHtml = colorOptions.map(opt => `<option value="${opt.value}" ${era.color === opt.value ? 'selected' : ''}>${opt.label}</option>`).join('');
      const opacityOptionsHtml = opacityOptions.map(opt => `<option value="${opt.value}" ${era.opacity === opt.value ? 'selected' : ''}>${opt.label}</option>`).join('');
      
      return `
        <div style="border: 1px solid #ddd; border-radius: 6px; margin: 8px 0; padding: 12px; background: #fdfdfd;">
          <div style="display: flex; gap: 16px;">
            <!-- Left Column -->
            <div style="flex: 1;">
              <!-- 1st row: Name, Start, End -->
              <div style="display: flex; gap: 12px; margin-bottom: 8px;">
                <div style="flex: 2;">
                  <label style="display: block; margin-bottom: 6px; font-weight: bold; font-size: 13px;">時代区分名:</label>
                  <input type="text" id="eraName${index}" value="${era.name}" style="width: 100%; padding: 6px; font-size: 14px; border: 1px solid #ccc; border-radius: 4px;">
                </div>
                <div style="flex: 1;">
                  <label style="display: block; margin-bottom: 6px; font-weight: bold; font-size: 13px;">開始年:</label>
                  <input type="number" id="eraStart${index}" value="${era.startYear}" style="width: 100%; padding: 6px; font-size: 14px; border: 1px solid #ccc; border-radius: 4px;">
                </div>
                <div style="flex: 1;">
                  <label style="display: block; margin-bottom: 6px; font-weight: bold; font-size: 13px;">終了年:</label>
                  <input type="number" id="eraEnd${index}" value="${era.endYear === 'ongoing' ? '' : era.endYear}" style="width: 100%; padding: 6px; font-size: 14px; border: 1px solid #ccc; border-radius: 4px;" ${era.endYear === 'ongoing' ? 'disabled' : ''}>
                  <div style="margin-top: 4px;">
                    <input type="checkbox" id="eraEndOngoing${index}" ${era.endYear === 'ongoing' ? 'checked' : ''} onchange="document.getElementById('eraEnd${index}').disabled = this.checked;">
                    <label for="eraEndOngoing${index}" style="font-size: 12px;">ongoing</label>
                  </div>
                </div>
              </div>
              <!-- 2nd row: Color, Opacity -->
              <div style="display: flex; gap: 12px;">
                <div style="flex: 1;">
                  <label style="display: block; margin-bottom: 6px; font-weight: bold; font-size: 13px;">塗色:</label>
                  <select id="eraColor${index}" style="width: 100%; padding: 6px; font-size: 14px; border: 1px solid #ccc; border-radius: 4px;">${colorOptionsHtml}</select>
                </div>
                <div style="flex: 1;">
                  <label style="display: block; margin-bottom: 6px; font-weight: bold; font-size: 13px;">透明度:</label>
                  <select id="eraOpacity${index}" style="width: 100%; padding: 6px; font-size: 14px; border: 1px solid #ccc; border-radius: 4px;">${opacityOptionsHtml}</select>
                </div>
              </div>
            </div>
            <!-- Right Column -->
            <div style="width: 100px; display: flex; flex-direction: column; justify-content: space-between; align-items: flex-start; border-left: 1px solid #eee; padding-left: 16px;">
              <div>
                <input type="checkbox" id="eraEnabled${index}" ${era.enabled ? 'checked' : ''} onchange="document.getElementById('eraFill${index}').disabled = !this.checked;" style="transform: scale(1.2);">
                <label for="eraEnabled${index}" style="font-size: 13px; margin-left: 4px;">表示</label>
              </div>
              <div style="margin-top: 8px;">
                <input type="checkbox" id="eraFill${index}" ${era.fillEnabled ?? true ? 'checked' : ''} ${!era.enabled ? 'disabled' : ''} style="transform: scale(1.2);">
                <label for="eraFill${index}" style="font-size: 13px; margin-left: 4px;">塗り</label>
              </div>
              <div style="margin-top: auto;">
                <button onclick="deleteEraItem(${index})" style="padding: 6px 12px; font-size: 12px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer;" title="この時代区分を削除">🗑️ 削除</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }).join('');

    const modalContent = `
      <div style="max-height: 400px; overflow-y: auto;">
        ${eraItems}
        ${eraSettings.length < 8 ? `
          <div style="border: 2px dashed #ccc; margin: 8px 0; padding: 12px; border-radius: 6px; text-align: center; cursor: pointer;" onclick="addEraItem()">
            + 新しい時代区分を追加
          </div>
        ` : ''}
      </div>
      <div style="margin-top: 16px; display: flex; gap: 8px; justify-content: center;">
        <button onclick="saveEraSettings()" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">保存</button>
      </div>
    `;
    openModal('時代区分設定', modalContent);
  }
  
  // 新しい時代区分項目を追加
  function addEraItem() {
    const newItem = {
      name: '',
      startYear: '',
      endYear: '',
      color: '#4169E1',
      opacity: '0.3',
      enabled: true,
      fillEnabled: true,
    };
    eraSettings.unshift(newItem);
    showEraSettingsModal();
  }
  
  // 時代区分項目を削除
  function deleteEraItem(index) {
    if (confirm('この時代区分を削除しますか？')) {
      eraSettings.splice(index, 1);
      saveEvents();
      renderEraBackgrounds();
      showEraSettingsModal();
    }
  }
  
  // 時代区分設定を保存
  function saveEraSettings() {
    const newEraSettings = [];
    const nameInputs = document.querySelectorAll('[id^="eraName"]');
    
    nameInputs.forEach(nameInput => {
      const name = nameInput.value.trim();
      if (name) {
        const index = nameInput.id.replace('eraName', '');
        const enabled = document.getElementById(`eraEnabled${index}`)?.checked ?? true;
        const fillEnabled = document.getElementById(`eraFill${index}`)?.checked ?? true;
        const startYearStr = document.getElementById(`eraStart${index}`)?.value.trim();
        const endYearStr = document.getElementById(`eraEnd${index}`)?.value.trim();
        const endOngoing = document.getElementById(`eraEndOngoing${index}`)?.checked ?? false;
        const color = document.getElementById(`eraColor${index}`)?.value || '#4169E1';
        const opacity = document.getElementById(`eraOpacity${index}`)?.value || '0.3';
        
        const startYear = startYearStr ? parseInt(startYearStr, 10) : '';
        let endYear = endYearStr ? parseInt(endYearStr, 10) : '';
        if (endOngoing) endYear = 'ongoing';

        newEraSettings.push({ name, startYear, endYear, color, opacity, enabled, fillEnabled });
      }
    });

    eraSettings = newEraSettings;
    
    try {
      const data = {
        events: events,
        eraSettings: eraSettings
      };
      localStorage.setItem('timelineEventsV2', JSON.stringify(data));
    } catch (e) {
      console.error('ローカルストレージ保存エラー:', e);
    }
    
    closeModal();
    renderEraBackgrounds();
  }
  
  // 時代区分の背景色を描画
  function renderEraBackgrounds() {
    try {
      if (!stage || !gridG) return;
      
      document.querySelectorAll('.era-background, .era-text, .era-text-bg').forEach(el => el.remove());
      
      const enabledEras = (eraSettings || []).filter(era => era && era.enabled);
      
      enabledEras.forEach(era => {
        const startYear = era.startYear;
        const endYear = (era.endYear === 'ongoing') ? new Date().getFullYear() : era.endYear;
        if (!startYear || !endYear) return;

        const startY = yFromBirthYear(startYear);
        const endY = yFromBirthYear(endYear + 1);
        const height = endY - startY;
        
        if (height > 0) {
          if (era.fillEnabled ?? true) {
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('class', 'era-background');
            rect.setAttribute('x', ORIGIN_X);
            rect.setAttribute('y', startY);
            rect.setAttribute('width', width - ORIGIN_X);
            rect.setAttribute('height', height);
            rect.setAttribute('fill', era.color);
            rect.setAttribute('opacity', era.opacity);
            gridG.insertBefore(rect, gridG.firstChild);
          }

          const eraText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          eraText.setAttribute('class', 'era-text');
          eraText.textContent = `${era.name} (${era.startYear}-${era.endYear})`;
          eraText.setAttribute('x', ORIGIN_X + 10);
          eraText.setAttribute('y', startY + 20);
          eraText.setAttribute('style', 'font-size: 14px; fill: #333; cursor: pointer; user-select: none;');
          
          const textBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          textBg.setAttribute('class', 'era-text-bg');
          
          gridG.appendChild(eraText);
          const bbox = eraText.getBBox();
          
          textBg.setAttribute('x', bbox.x - 4);
          textBg.setAttribute('y', bbox.y - 2);
          textBg.setAttribute('width', bbox.width + 8);
          textBg.setAttribute('height', bbox.height + 4);
          textBg.setAttribute('fill', 'rgba(255,255,255,0.01)');
          textBg.setAttribute('style', 'cursor: pointer;');
          
          const toggleFill = () => {
            const originalIndex = eraSettings.findIndex(e => e.name === era.name && e.startYear === era.startYear && e.endYear === era.endYear);
            if (originalIndex > -1) {
              eraSettings[originalIndex].fillEnabled = !(eraSettings[originalIndex].fillEnabled ?? true);
              saveEvents(); 
              renderEraBackgrounds();
            }
          };
          
          eraText.addEventListener('click', toggleFill);
          textBg.addEventListener('click', toggleFill);
          
          gridG.insertBefore(textBg, eraText);
        }
      });
    } catch (error) {
      console.error('時代区分の描画エラー:', error);
    }
  }
  
  // 初期化時に時代区分背景を描画（後で実行）
  setTimeout(renderEraBackgrounds, 0);
  
  function passesFilter(it){ 
    // 削除フラグがオンの項目は除外
    if (it.deleted === true) {
      return false;
    }
    
    // ジャンルフィルタ（複数選択対応）
    if (selectedGenres.size === 0) {
      // 未選択なら何も表示しない
      return false;
    }
    if (!itemHasSelectedGenre(it)) return false;
    // 重要度フィルタ
    if(filterImp){ 
      const thr = parseInt(filterImp,10); 
      const imp = parseInt(it.imp,10); 
      if(isNaN(imp) || imp<thr) return false; 
    } 
    return true; 
  }

  // ===== グリッド =====
  function yFromBirthYear(by){return ORIGIN_Y+(by-YEAR_MIN)*PX_PER_YEAR;}
  function xFromAge(age){return ORIGIN_X+age*PX_PER_AGE;}
  function drawGrid(){
    for(let a=0;a<=AGE_MAX;a+=10){ const x=xFromAge(a); gridG.appendChild(lineEl(x,ORIGIN_Y-10,x,height-20,'gridMajor')); }
    for(let y=YEAR_MIN;y<=YEAR_MAX;y++){ const ypx=yFromBirthYear(y); gridG.appendChild(lineEl(ORIGIN_X,ypx,width-20,ypx,(y%10===0?'gridMajor':'gridMinor'))); if(y%10===0){ const decade=String(y).slice(2,3)+"0s"; const tt=textEl(decade, 36, ypx+18, 'axisLabel'); tt.setAttribute('text-anchor','middle'); decadesG.appendChild(tt); } }
    for(let b=YEAR_MIN; b<=YEAR_MAX; b+=5){ const x0=ORIGIN_X, y0=yFromBirthYear(b); const x1=xFromAge(Math.min(AGE_MAX,YEAR_MAX-b)); const y1=yFromBirthYear(Math.min(YEAR_MAX,b+AGE_MAX)); gridG.appendChild(lineEl(x0,y0,x1,y1,'gridMinor')); }
  }
  
  // 固定位置の年齢軸ラベルを作成
  function createFixedAgeLabels() {
    const fixedAgeContainer = document.createElement('div');
    fixedAgeContainer.id = 'fixed-age-labels';
    fixedAgeContainer.style.cssText = `
      position: fixed;
      top: 58px;
      left: 0;
      right: 0;
      height: 20px;
      pointer-events: none;
      z-index: 100;
      overflow: hidden;
    `;
    const inner = document.createElement('div');
    inner.id = 'fixed-age-labels-inner';
    inner.style.cssText = 'position: absolute; left: 0; top: 0; height: 20px;';
    for(let a=0;a<=AGE_MAX;a+=10){
      const x = xFromAge(a);
      const label = document.createElement('div');
      label.textContent = a;
      label.style.cssText = `
        position: absolute;
        left: ${x}px;
        top: 0;
        font-size: 18px;
        font-weight: 700;
        color: #4a4a4a;
        transform: translateX(-50%);
        pointer-events: none;
      `;
      inner.appendChild(label);
    }
    fixedAgeContainer.appendChild(inner);
    document.body.appendChild(fixedAgeContainer);
  }
  
  // 年齢目盛り数字の背景に白い帯を作成
  function createAgeBand() {
    const bandContainer = document.createElement('div');
    bandContainer.id = 'age-band';
    bandContainer.style.cssText = `
      position: fixed;
      top: 54px;
      left: 0;
      right: 0;
      height: 24px;
      pointer-events: none;
      z-index: 3;
      overflow: hidden;
    `;
    const inner = document.createElement('div');
    inner.id = 'age-band-inner';
    inner.style.cssText = 'position: absolute; left: 0; top: 0; height: 24px;';
    const ageBand = document.createElement('div');
    ageBand.style.cssText = `
      position: absolute;
      left: ${ORIGIN_X}px;
      top: 0;
      width: ${xFromAge(AGE_MAX) - ORIGIN_X}px;
      height: 20px;
      background: white;
      pointer-events: none;
    `;
    inner.appendChild(ageBand);
    bandContainer.appendChild(inner);
    document.body.appendChild(bandContainer);
  }
  
  // ヘッダーの高さを取得して年齢表示の位置を調整する関数
  function updateAgeDisplayPosition() {
    const header = document.querySelector('header');
    const ageLabels = document.getElementById('fixed-age-labels');
    const ageLabelsInner = document.getElementById('fixed-age-labels-inner');
    const ageBand = document.getElementById('age-band');
    const ageBandInner = document.getElementById('age-band-inner');
    const ageTextBlue = document.getElementById('age-text-blue');
    const ageTextRed = document.getElementById('age-text-red');
    
    if (header && ageLabels && ageBand) {
      const headerHeight = header.offsetHeight;
      const newTop = headerHeight + 4; // ヘッダーの下に4pxの余白
      
      ageLabels.style.top = `${newTop}px`;
      ageBand.style.top = `${newTop - 4}px`;
      
      // スマホ時: 横スクロールに合わせて年齢目盛りをずらす
      const isMobile = window.innerWidth <= 768;
      const scrollLeft = vp ? vp.scrollLeft : 0;
      if (ageLabelsInner) {
        ageLabelsInner.style.left = isMobile ? `${-scrollLeft}px` : '0';
      }
      if (ageBandInner) {
        ageBandInner.style.left = isMobile ? `${-scrollLeft}px` : '0';
      }
      
      if (ageTextBlue) ageTextBlue.style.top = `${newTop + 20}px`;
      if (ageTextRed) ageTextRed.style.top = `${newTop + 20}px`;
    }
  }

  // プローブ用 右側イベント一覧パネルの更新
  const probeEventsPanel = document.getElementById('probeEventsPanel');
  const probeCheckedKeys = new Set();
  let lastProbeEventYear = null;
  if (probeEventsPanel) {
    probeEventsPanel.addEventListener('change', (e)=>{
      const t = e.target;
      if (!t || t.tagName !== 'INPUT') return;
      const year = t.getAttribute('data-year');
      const idx  = t.getAttribute('data-index');
      if (!year || idx === null) return;
      const key = `${year}|${idx}`;
      if (t.checked) {
        probeCheckedKeys.add(key);
        // キオスク用の選択カウントに反映
        if (window.kioskMode && window.kioskState) {
          const yNum = Number(year);
          const items = (events[yNum] || []).filter(passesFilter);
          const item = items[Number(idx)];
          if (item) {
            const exists = window.kioskState.selections.some(s => s.year === yNum && s.label === item.label);
            if (!exists) {
              window.kioskState.selections.push({
                year: yNum,
                label: item.label,
                genre: item.genre,
                imp: item.imp
              });
            }
          }
        }
      } else {
        probeCheckedKeys.delete(key);
        if (window.kioskMode && window.kioskState) {
          const yNum = Number(year);
          const items = (events[yNum] || []).filter(passesFilter);
          const item = items[Number(idx)];
          if (item) {
            const i = window.kioskState.selections.findIndex(s => s.year === yNum && s.label === item.label);
            if (i !== -1) window.kioskState.selections.splice(i,1);
          }
        }
      }
      if (window.kioskMode && window.kioskState && window.kioskState.step === 3) {
        window.kioskState.step3StartedOperating = true;
      }
      if (window.kioskMode && typeof updateKioskHint === 'function') {
        updateKioskHint();
      }
    });
  }
  function updateProbeEventsPanel(year){
    if (!probeEventsPanel) return;
    const y = Math.round(year);
    const items = (events[y] || []).filter(passesFilter);
    if (!items.length){
      probeEventsPanel.style.display = 'none';
      probeEventsPanel.innerHTML = '';
      lastProbeEventYear = null;
      return;
    }
    const listHtml = items.map((item, idx) => {
      const key = `${y}|${idx}`;
      const checkedAttr = probeCheckedKeys.has(key) ? 'checked' : '';
      const jpUrl = item.url || '';
      const enUrl = item.url_e || item.url_en || item.URL_en || item.URL_e || item.urlEn || '';
      const hasJpUrl = !!jpUrl;
      const hasEnUrl = !!enUrl;
      const labelEn = item.label_en || '';
      return `
        <li>
          <label style="display:inline-flex; align-items:center; gap:8px; cursor:pointer; font-size:18px; flex-wrap:wrap;">
            <input type="checkbox" data-year="${y}" data-index="${idx}" style="margin-right:8px; transform:scale(1.2); flex-shrink:0;" ${checkedAttr}>
            <strong style="flex-shrink:0;">${item.label}</strong>
            ${hasJpUrl ? `<span class="probe-web-icon" data-web-url="${jpUrl}" title="関連ページを表示" style="cursor:pointer; flex-shrink:0;">🌐</span>` : ''}
            <span style="display:inline; font-size:18px;">${labelEn ? `<span style="color:#444;">${labelEn}</span>` : ''}${(labelEn && hasEnUrl) ? ' ' : ''}${hasEnUrl ? `<span class="probe-web-icon" data-web-url="${enUrl}" title="English page" style="cursor:pointer;">🌐</span>` : ''}</span>
          </label>
        </li>
      `;
    }).join('');
    const cfr = getCfrPrompts();
    const desc = cfr.eventChecklistDescription || DEFAULT_CFR_PROMPTS.eventChecklistDescription;
    probeEventsPanel.innerHTML = `
      <h4>${y}年のイベント</h4>
      <p style="margin:2px 0 4px; font-size:18px; color:#666;">${(desc || '').replace(/</g,'&lt;')}</p>
      <ul>${listHtml}</ul>
    `;
    // イベント年の〇の少し右に出す（スクロール時に追従できるよう座標を記録）
    lastProbeEventYear = y;
    const rect = stage.getBoundingClientRect();
    const ySvg = yFromBirthYear(y);
    const xSvg = HANDLE_X;
    const clientX = rect.left + xSvg;
    const clientY = rect.top + ySvg;
    const offsetX = 36;
    const offsetY = -40;
    const vpRect = vp.getBoundingClientRect();
    // 一度表示して高さを取得
    probeEventsPanel.style.display = 'block';
    const panelH = probeEventsPanel.offsetHeight || 200;
    const panelW = probeEventsPanel.offsetWidth || 260;
    let left = clientX + offsetX;
    let top  = clientY + offsetY;
    const minLeft = vpRect.left + 8;
    const maxLeft = vpRect.right - panelW - 8;
    const minTop  = vpRect.top + 8;
    const maxTop  = vpRect.bottom - panelH - 8;
    left = Math.max(minLeft, Math.min(maxLeft, left));
    top  = Math.max(minTop,  Math.min(maxTop,  top));
    probeEventsPanel.style.left = `${left}px`;
    probeEventsPanel.style.top  = `${top}px`;
  }
  window.updateProbeEventsPanel = updateProbeEventsPanel;
  // ビューポートがスクロールされたら、最後に表示した年に合わせて位置だけ更新
  vp.addEventListener('scroll', () => {
    if (!probeEventsPanel || probeEventsPanel.style.display === 'none') return;
    if (lastProbeEventYear == null) return;
    const y = lastProbeEventYear;
    const rect = stage.getBoundingClientRect();
    const ySvg = yFromBirthYear(y);
    const xSvg = HANDLE_X;
    const clientX = rect.left + xSvg;
    const clientY = rect.top + ySvg;
    const offsetX = 36;
    const offsetY = -40;
    const vpRect = vp.getBoundingClientRect();
    const panelH = probeEventsPanel.offsetHeight || 200;
    const panelW = probeEventsPanel.offsetWidth || 260;
    let left = clientX + offsetX;
    let top  = clientY + offsetY;
    const minLeft = vpRect.left + 8;
    const maxLeft = vpRect.right - panelW - 8;
    const minTop  = vpRect.top + 8;
    const maxTop  = vpRect.bottom - panelH - 8;
    left = Math.max(minLeft, Math.min(maxLeft, left));
    top  = Math.max(minTop,  Math.min(maxTop,  top));
    probeEventsPanel.style.left = `${left}px`;
    probeEventsPanel.style.top  = `${top}px`;
  });

  // ===== ウェブプレビュー（地球マークホバー用） =====
  let webPreviewEl = null;
  let webPreviewOverlay = null;
  let webPreviewFrame = null;
  let webPreviewHideTimer = null;
  function ensureWebPreview(){
    if (webPreviewEl) return webPreviewEl;
    webPreviewOverlay = document.createElement('div');
    webPreviewOverlay.id = 'kioskWebPreviewOverlay';
    webPreviewOverlay.style.cssText = 'position:fixed; inset:0; background:rgba(0,0,0,.4); z-index:2499; display:none;';
    webPreviewOverlay.addEventListener('click', () => { hideWebPreview(); });
    document.body.appendChild(webPreviewOverlay);
    webPreviewEl = document.createElement('div');
    webPreviewEl.id = 'kioskWebPreview';
    webPreviewEl.style.cssText = 'position:fixed; width:70vw; height:80vh; max-width:1100px; background:#fff; border-radius:8px; box-shadow:0 8px 32px rgba(0,0,0,.45); border:1px solid #ccc; z-index:2500; display:none; overflow:hidden;';
    webPreviewFrame = document.createElement('iframe');
    webPreviewFrame.style.cssText = 'width:100%; height:100%; border:0;';
    webPreviewEl.appendChild(webPreviewFrame);
    document.body.appendChild(webPreviewEl);
    webPreviewEl.addEventListener('mouseenter', () => {
      if (webPreviewHideTimer) {
        clearTimeout(webPreviewHideTimer);
        webPreviewHideTimer = null;
      }
    });
    webPreviewEl.addEventListener('mouseleave', () => {
      if (!isWebPreviewMobile()) hideWebPreview();
    });
    return webPreviewEl;
  }
  function isWebPreviewMobile() {
    return window.matchMedia('(max-width: 768px)').matches;
  }
  function showWebPreview(url, anchor){
    if (!url) return;
    const el = ensureWebPreview();
    webPreviewFrame.src = url;
    const z = pageZoom || 1;
    if (isWebPreviewMobile()) {
      // スマホ: 幅8割・左に余白・上下1割ずつ短く、外タップで閉じる
      if (webPreviewOverlay) {
        webPreviewOverlay.style.display = 'block';
      }
      el.style.left = '10vw';
      el.style.top = '10vh';
      el.style.width = '80vw';
      el.style.height = '80vh';
      el.style.maxWidth = 'none';
      el.style.borderRadius = '12px';
    } else {
      const rect = anchor.getBoundingClientRect();
      let left = (rect.right + 8) / z;
      let top  = (window.innerHeight * 0.1) / z;
      el.style.left = `${left}px`;
      el.style.top  = `${top}px`;
      el.style.width = '70vw';
      el.style.height = '80vh';
      el.style.maxWidth = '1100px';
      el.style.borderRadius = '8px';
    }
    el.style.display = 'block';
  }
  function hideWebPreview(){
    if (webPreviewOverlay) webPreviewOverlay.style.display = 'none';
    if (webPreviewEl) {
      webPreviewEl.style.display = 'none';
      webPreviewEl.style.width = '';
      webPreviewEl.style.height = '';
      webPreviewEl.style.maxWidth = '';
      webPreviewEl.style.left = '';
      webPreviewEl.style.top = '';
      webPreviewEl.style.borderRadius = '';
    }
    if (webPreviewFrame) webPreviewFrame.src = 'about:blank';
  }
  // 地球マークにホバー（PC）またはタップ（スマホ）でプレビュー表示
  document.addEventListener('mouseover', (e) => {
    if (isWebPreviewMobile()) return;
    const target = e.target;
    if (target && target.classList && target.classList.contains('probe-web-icon')) {
      const url = target.getAttribute('data-web-url');
      if (webPreviewHideTimer) {
        clearTimeout(webPreviewHideTimer);
        webPreviewHideTimer = null;
      }
      showWebPreview(url, target);
    }
  });
  document.addEventListener('mouseout', (e) => {
    if (isWebPreviewMobile()) return;
    const target = e.target;
    if (target && target.classList && target.classList.contains('probe-web-icon')) {
      if (webPreviewHideTimer) clearTimeout(webPreviewHideTimer);
      webPreviewHideTimer = setTimeout(() => {
        hideWebPreview();
      }, 150);
    }
  });
  document.addEventListener('click', (e) => {
    if (!isWebPreviewMobile()) return;
    const target = e.target;
    if (target && target.classList && target.classList.contains('probe-web-icon')) {
      e.preventDefault();
      const url = target.getAttribute('data-web-url');
      if (url) showWebPreview(url, target);
    }
  }, true);
  
  try {
  drawGrid();
    createFixedAgeLabels();
    createAgeBand();
    updateAgeDisplayPosition(); // 年齢表示の位置を調整
    updateGenreFilterButtonText();
  } catch (error) {
    console.error('初期化エラー:', error);
  }

  const tooltip=document.getElementById('tooltip');
  function positionTooltip(e){const r=vp.getBoundingClientRect();tooltip.style.left=(e.clientX-r.left+14)+'px';tooltip.style.top=(e.clientY-r.top+14)+'px';}

  // ===== 詳細一覧表示 =====
  function showDetailList(year, anchor) {
    clearHighlight();
    const items = (events[year] || []).filter(passesFilter);

    editor.innerHTML = `
      <h4 style="display: flex; align-items: center; justify-content: space-between; margin: 0 0 12px 0; font-size: 16px;">
        <span style="display: flex; align-items: center; gap: 8px;">
          <span style="cursor: pointer; font-size: 18px;" onclick="openYearWikipedia(${year})" title="${year}年のWikipediaページを開く">🌐</span>
          <span>${year}年</span>
        </span>
        <span style="font-size: 11px; color: #666; font-weight: normal;">ドラッグで一覧の順序を変更できます</span>
      </h4>
      <div style="max-height: 400px; overflow-y: auto; width: 500px;" id="detailListContainer">
        ${items.length > 0 ? items.map((item, index) => {
          // 元の配列での実際のインデックスを取得
          const allItems = events[year] || [];
          const actualIndex = allItems.findIndex(originalItem => 
            originalItem.label === item.label && originalItem.genre === item.genre
          );
          return `
          <div class="detail-item" data-year="${year}" data-index="${actualIndex}" style="border: 1px solid #ddd; margin: 8px 0; padding: 12px; border-radius: 6px; background: #f9f9f9; cursor: move; user-select: none;" draggable="true">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div style="flex: 1;">
                <div style="font-weight: bold; margin-bottom: 4px;">${item.label}</div>
                <div style="font-size: 12px; color: #666;">
                  ${item.genre ? `ジャンル: ${Array.isArray(item.genre) ? item.genre.join('・') : item.genre}` : ''}
                  ${item.imp ? ` | 重要度: ${item.imp}` : ''}
                  ${item.note ? ` | 注釈: ${item.note}` : ''}
                </div>
              </div>
              <div style="display: flex; gap: 8px;">
                <button onclick="addEraFromItem(${year}, ${actualIndex})" style="padding: 4px 8px; font-size: 12px;" title="この項目から時代区分を登録">📅</button>
                <button onclick="openUrl('${item.url || ''}')" style="padding: 4px 8px; font-size: 12px;" ${!item.url ? 'disabled' : ''}>🌐</button>
                <button onclick="editItem(${year}, ${actualIndex})" style="padding: 4px 8px; font-size: 12px;">✏️</button>
                <button onclick="deleteItem(${year}, ${actualIndex})" style="padding: 4px 8px; font-size: 12px; color: #d32f2f;">🗑️</button>
              </div>
            </div>
          </div>
        `;
        }).join('') : '<div style="text-align: center; color: #666; padding: 20px;">項目がありません</div>'}
      </div>
      <div class="row">
        <div class="left"></div>
        <div class="right">
          <button id="addBtn">追加</button>
          <button id="closeBtn">閉じる</button>
        </div>
      </div>`;
    
    const r = anchor ? anchor.getBoundingClientRect() : {right: 100, top: 100};
    const rv = vp.getBoundingClientRect();
    let left = r.right - rv.left + 8;
    let top = r.top - rv.top;
    const maxLeft = rv.width - 520;
    if(left > maxLeft) left = Math.max(12, r.left - rv.left - 520);
    
    editor.style.left = left + 'px';
    editor.style.top = top + 'px';
    editor.style.display = 'block';

    function close() { 
      saveEvents();
      renderEvents();
      autoSave();
      editor.style.display = 'none'; 
    }
    editor.querySelector('#addBtn').onclick = () => { addNewItem(year); };
    editor.querySelector('#closeBtn').onclick = close;
    
    // ドラッグ&ドロップイベントを設定
    setupDragAndDrop(year);
  }

  // ===== ドラッグ&ドロップ機能 =====
  function setupDragAndDrop(year) {
    const container = document.getElementById('detailListContainer');
    if (!container) return;
    
    let draggedElement = null;
    let draggedIndex = null;
    
    // ドラッグ開始
    container.addEventListener('dragstart', (e) => {
      if (e.target.classList.contains('detail-item')) {
        draggedElement = e.target;
        draggedIndex = parseInt(e.target.dataset.index);
        e.target.style.opacity = '0.5';
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', e.target.outerHTML);
      }
    });
    
    // ドラッグ終了
    container.addEventListener('dragend', (e) => {
      if (e.target.classList.contains('detail-item')) {
        e.target.style.opacity = '';
        draggedElement = null;
        draggedIndex = null;
      }
    });
    
    // ドラッグオーバー
    container.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      
      const afterElement = getDragAfterElement(container, e.clientY);
      if (afterElement == null) {
        container.appendChild(draggedElement);
      } else {
        container.insertBefore(draggedElement, afterElement);
      }
    });
    
    // ドロップ
    container.addEventListener('drop', (e) => {
      e.preventDefault();
      
      if (draggedElement && draggedIndex !== null) {
        const newIndex = Array.from(container.children).indexOf(draggedElement);
        
        if (newIndex !== draggedIndex) {
          // 項目の順序を変更
          const items = events[year] || [];
          const item = items.splice(draggedIndex, 1)[0];
          items.splice(newIndex, 0, item);
          
          // 順番変更フラグを設定
          setOrderChanged(true);
          
          // データを保存して画面を更新
          saveEvents();
          renderEvents();
          showDetailList(year, null);
        }
      }
    });
  }
  
  // ドラッグ後の要素位置を取得
  function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.detail-item:not(.dragging)')];
    
    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height / 2;
      
      if (offset < 0 && offset > closest.offset) {
        return { offset: offset, element: child };
      } else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }

  // ===== 詳細一覧の操作関数 =====
  function moveItem(year, index, direction) {
    const items = events[year] || [];
    const newIndex = index + direction;
    if (newIndex < 0 || newIndex >= items.length) return;
    
    // 項目を移動
    const item = items.splice(index, 1)[0];
    items.splice(newIndex, 0, item);
    
    // 順番変更フラグを設定
    setOrderChanged(true);
    
    saveEvents();
    renderEvents();
    showDetailList(year, null);
  }

  function openUrl(url) {
    if (url && url.startsWith('http')) {
      window.open(url, '_blank');
    }
  }
  
  function openYearWikipedia(year) {
    // Wikipediaの年ページのURL形式（「年」なし）
    const wikipediaUrl = `https://ja.wikipedia.org/wiki/${year}年`;
    console.log('Wikipedia URL:', wikipediaUrl); // デバッグ用
    window.open(wikipediaUrl, '_blank');
  }

  function editItem(year, index) {
    const items = events[year] || [];
    const item = items[index];
    if (!item) return;
    
    // 編集前のデータをバックアップとして保存
    setLabelBackup(year, item.label, item.genre, { ...item });
    
    showEditModal(year, index, item);
  }

  function deleteItem(year, index) {
    const items = events[year] || [];
    const item = items[index];
    if (!item) return;
    
    if (confirm(`「${item.label}」を削除しますか？`)) {
      // CSVエクスポート用に削除前の内容を記録
      addDeletionRecord(year, item);
      // 物理削除
      items.splice(index, 1);
      if (items.length === 0) delete events[year];
      console.log('項目を物理削除:', { year, index, label: item.label });
      saveEvents();
      renderEvents();
      showDetailList(year, null);
    }
  }

  function addNewItem(year) {
    showEditModal(year, -1, { label: '', startYear: year, endYear: '' });
  }

  // 個別編集用ポップアップ
  function showEditModal(year, index, item) {
    clearHighlight();
    
    editor.innerHTML = `
      <h4><span>項目の編集</span></h4>
      <div style="margin-bottom: 16px;">
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">開始年:</label>
        <input type="number" id="editStartYear" value="${item.startYear || ''}" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" placeholder="例: 1952" min="${YEAR_MIN}" max="${YEAR_MAX}">
      </div>
      
      <div style="margin-bottom: 16px;">
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">終了年:</label>
        <div style="display: flex; gap: 8px; align-items: center;">
          <input type="number" id="editEndYear" value="${item.endYear === 'ongoing' ? '' : (item.endYear || '')}" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" placeholder="例: 1968" min="${YEAR_MIN}" max="${YEAR_MAX}">
          <label style="display: flex; align-items: center; gap: 4px; font-size: 14px;">
            <input type="checkbox" id="editEndYearOngoing" ${item.endYear === 'ongoing' ? 'checked' : ''} style="margin: 0;">
            継続中 (ongoing)
          </label>
        </div>
      </div>
      
      <div style="margin-bottom: 16px;">
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">ラベル:</label>
        <input type="text" id="editLabel" value="${item.label || ''}" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
      </div>
      
      <div style="margin-bottom: 16px;">
        <label style="display: block; margin-bottom: 8px; font-weight: bold;">ジャンル:</label>
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; border: 1px solid #ddd; border-radius: 4px; padding: 8px;">
          ${GENRES.map(code => `
          <label style=\"display: flex; align-items: center; gap: 4px; font-size: 13px;\">
            <input type=\"checkbox\" value=\"${code}\" ${Array.isArray(item.genre) ? (item.genre.includes(code) ? 'checked' : '') : (item.genre === code ? 'checked' : '')}>
            ${GENRE_LABELS[code] || code}
          </label>`).join('')}
        </div>
      </div>
      
      <div style="margin-bottom: 16px;">
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">重要度:</label>
        <select id="editImp" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
          <option value="">選択してください</option>
          <option value="5" ${item.imp === 5 ? 'selected' : ''}>5 - 時代を代表する重要イベント</option>
          <option value="4" ${item.imp === 4 ? 'selected' : ''}>4 - 大きな影響を与えたイベント</option>
          <option value="3" ${item.imp === 3 ? 'selected' : ''}>3 - 一般的に知られているイベント</option>
          <option value="2" ${item.imp === 2 ? 'selected' : ''}>2 - 特定分野で重要なイベント</option>
          <option value="1" ${item.imp === 1 ? 'selected' : ''}>1 - 参考程度のイベント</option>
        </select>
      </div>
      
      <div style="margin-bottom: 16px;">
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">URL:</label>
        <input type="url" id="editUrl" value="${item.url || ''}" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" placeholder="https://example.com">
      </div>
      
      <div style="margin-bottom: 16px;">
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">注釈:</label>
        <textarea id="editNote" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; height: 80px;" placeholder="補足説明やメモ">${item.note || ''}</textarea>
      </div>
      
      <div class="row">
        <div class="left"></div>
        <div class="right">
          <button id="cancel">キャンセル</button>
          <button id="save">保存</button>
        </div>
      </div>`;
    
    const rv = vp.getBoundingClientRect();
    editor.style.left = (rv.width / 2 - 250) + 'px';
    editor.style.top = (rv.height / 2 - 200) + 'px';
    editor.style.display = 'block';
    editor.style.zIndex = '1000';

    function close() { editor.style.display = 'none'; }
    editor.querySelector('#cancel').onclick = close;
    editor.querySelector('#save').onclick = () => { saveEditItem(year, index); };
    // 入力中の長さ制限（URL + 注釈 合計最大512文字）
    const urlEl = document.getElementById('editUrl');
    const noteEl = document.getElementById('editNote');
    const limit = 512;
    function enforceLimit(e){
      const urlVal = urlEl.value || '';
      const noteVal = noteEl.value || '';
      const total = urlVal.length + noteVal.length;
      if(total > limit){
        // 超過分をカット
        if(e && e.target === noteEl){
          noteEl.value = noteVal.slice(0, Math.max(0, limit - urlVal.length));
        } else if(e && e.target === urlEl){
          urlEl.value = urlVal.slice(0, Math.max(0, limit - noteVal.length));
        }
        showError('入力制限', `URLと注釈の合計は最大 ${limit} 文字までです。`);
      }
    }
    urlEl.addEventListener('input', enforceLimit);
    noteEl.addEventListener('input', enforceLimit);
  }

  function saveEditItem(year, index) {
    const startYear = document.getElementById('editStartYear').value.trim();
    const endYearInput = document.getElementById('editEndYear').value.trim();
    const endYearOngoing = document.getElementById('editEndYearOngoing').checked;
    const endYear = endYearOngoing ? 'ongoing' : endYearInput;
    const label = document.getElementById('editLabel').value.trim();
    const genreCheckboxes = document.querySelectorAll('input[type="checkbox"][value]');
    const genres = Array.from(genreCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
    const imp = document.getElementById('editImp').value.trim();
    const url = document.getElementById('editUrl').value.trim();
    const note = document.getElementById('editNote').value.trim();
    const totalLen = (url || '').length + (note || '').length;
    if(totalLen > 512){
      showError('編集エラー', `URLと注釈の合計は最大 512 文字までです。現在: ${totalLen} 文字`);
      return;
    }
    
    // 年の範囲チェック（1945～2059）
    const RANGE_MIN = 1945;
    const RANGE_MAX = 2059;
    const isYearInRange = (v) => v === '' || (String(v).toLowerCase()==='ongoing') || (/^\d{4}$/.test(v) && parseInt(v,10)>=RANGE_MIN && parseInt(v,10)<=RANGE_MAX);
    if (!isYearInRange(startYear)) {
      showError('編集エラー', `開始年は${RANGE_MIN}～${RANGE_MAX}の範囲で入力してください。`);
      const se = document.getElementById('editStartYear');
      if (se) se.value = '';
      return;
    }
    if (!isYearInRange(endYear)) {
      showError('編集エラー', `終了年は${RANGE_MIN}～${RANGE_MAX}の範囲で入力してください（または「ongoing」）。`);
      const ee = document.getElementById('editEndYear');
      if (ee) ee.value = '';
      return;
    }

    if (!label) {
      showError('編集エラー', 'ラベルは必須です。');
      return;
    }
    
    // 重複チェック（ラベル・ジャンル組み合わせ）
    const genreKey = genres.length > 0 ? genres.sort().join('・') : '';
    const key = `${label}|${genreKey}`;
    const existingItems = buildLabelGenreSet();
    
    // 編集の場合（index !== -1）は、自分自身との重複は除外
    if (index !== -1) {
      const currentItem = events[year][index];
      const currentGenreKey = Array.isArray(currentItem.genre) ? currentItem.genre.sort().join('・') : (currentItem.genre || '');
      const currentKey = `${currentItem.label}|${currentGenreKey}`;
      if (key === currentKey) {
        // 同じラベル・ジャンル組み合わせなので重複チェックをスキップ
      } else if (existingItems.has(key)) {
        showError('重複エラー', `同じラベル・ジャンル組み合わせが既に存在します（${label}${genreKey ? ` [${genreKey}]` : ''}）`);
        return;
      }
    } else {
      // 新規追加の場合
      if (existingItems.has(key)) {
        showError('重複エラー', `同じラベル・ジャンル組み合わせが既に存在します（${label}${genreKey ? ` [${genreKey}]` : ''}）`);
        return;
      }
    }
    
    const newItem = { label };
    if (startYear) newItem.startYear = parseInt(startYear, 10);
    if (endYear) {
      if (endYear === 'ongoing') {
        newItem.endYear = 'ongoing';
      } else {
        newItem.endYear = parseInt(endYear, 10);
      }
    }
    if (genres.length > 0) newItem.genre = genres;
    if (imp) newItem.imp = parseInt(imp, 10);
    if (url) newItem.url = url;
    if (note) newItem.note = note;
    
    if (index === -1) {
      // 新しい項目を追加
      const targetYear = startYear ? parseInt(startYear, 10) : year;
      if (!events[targetYear]) {
        events[targetYear] = [];
      }
      events[targetYear].push(newItem);
      // 新規追加の場合は編集フラグを設定
      setEditFlag(targetYear, newItem.label, genreKey);
    } else {
      // 既存の項目を更新
      const currentItem = events[year][index];
      const originalStartYear = currentItem.startYear || year;
      const newStartYear = startYear ? parseInt(startYear, 10) : year;
      const originalLabel = currentItem.label || '';
      const originalGenreKey = Array.isArray(currentItem.genre) ? currentItem.genre.slice().sort().join('・') : (currentItem.genre || '');
      const changedLabel = originalLabel !== label;
      const changedGenre = originalGenreKey !== genreKey;
      
      // 開始年・ラベル・ジャンルのいずれかが変更された場合は、元データを物理削除し、新規レコードを追加
      if (originalStartYear !== newStartYear || changedLabel || changedGenre) {
        // 旧項目を削除記録に追加して物理削除
        addDeletionRecord(year, currentItem);
        // 指定インデックスの項目を削除
        if (Array.isArray(events[year])) {
          events[year].splice(index, 1);
          // 同一ラベル・ジャンルの残存レコードがあれば全て除去（重複対策）
          const sameMatcher = (it) => {
            const gA = Array.isArray(it.genre) ? it.genre.slice().sort().join('・') : (it.genre || '');
            return (it.label||'') === originalLabel && gA === originalGenreKey;
          };
          events[year] = events[year].filter(it => !sameMatcher(it));
          if (events[year].length === 0) delete events[year];
        }
        console.log('識別子変更に伴い旧項目を物理削除:', { year, index, originalLabel, originalGenreKey, originalStartYear });

        // 新しい年に項目を追加
        const targetYearForNew = newStartYear;
        if (!events[targetYearForNew]) {
          events[targetYearForNew] = [];
        }
        events[targetYearForNew].push(newItem);
        
        // 編集フラグを設定（新しいレコードに対して）
        setEditFlag(targetYearForNew, newItem.label, genreKey);
      } else {
        // 識別子に変更がなければ通常の上書き更新
        events[year][index] = newItem;
        setEditFlag(year, newItem.label, genreKey);
      }
    }
    
    saveEvents();
    renderEvents();
    autoSave();
    
    // 編集画面を自動で閉じる
    editor.style.display = 'none';
  }

  // 個別の項目から時代区分を登録する機能
  function addEraFromItem(year, index) {
    const items = events[year] || [];
    const item = items[index];
    if (!item) {
      showError('エラー', '項目が見つかりません。');
      return;
    }
    
    const startYear = item.startYear || year;
    // 項目の終了年が「ongoing」の場合は時代区分も「ongoing」に設定
    const endYear = item.endYear === 'ongoing' ? 'ongoing' : (item.endYear || year);
    const eraName = item.label + (item.genre ? ` [${Array.isArray(item.genre) ? item.genre.join('・') : item.genre}]` : '');
    
    console.log('addEraFromItem: 項目情報', {
      itemLabel: item.label,
      itemStartYear: item.startYear,
      itemEndYear: item.endYear,
      eraStartYear: startYear,
      eraEndYear: endYear
    });
    
    // 既存の時代区分があるかチェック
    const existingEraIndex = eraSettings.findIndex(era => 
      era.name === eraName && 
      era.startYear === startYear && 
      era.endYear === endYear
    );
    
    if (existingEraIndex !== -1) {
      // 既存の時代区分を削除
      eraSettings.splice(existingEraIndex, 1);
      saveEvents();
      renderEraBackgrounds();
      return;
    }
    
    // 利用可能な色のリスト
    const availableColors = [
      '#4169E1', '#32CD32', '#DC143C', '#FF8C00', 
      '#8A2BE2', '#00CED1', '#FFD700', '#696969',
      '#FF69B4', '#00FF7F', '#FF4500', '#9370DB',
      '#20B2AA', '#FFA500', '#FF1493', '#32CD32'
    ];
    
    // 既に使用されている色を取得
    const usedColors = eraSettings.map(era => era.color);
    
    // 未使用の色を選択
    let selectedColor = availableColors.find(color => !usedColors.includes(color));
    if (!selectedColor) {
      // 全ての色が使用されている場合は最初の色を使用
      selectedColor = availableColors[0];
    }
    
    const newEra = {
      name: eraName,
      startYear: startYear,
      endYear: endYear,
      color: selectedColor,
      opacity: '0.3',
      enabled: true
    };
    
    console.log('addEraFromItem: 作成する時代区分', newEra);
    
    // 新しい時代区分を先頭に追加（常に新しいものから並ぶように）
    eraSettings.unshift(newEra);
    
    // 保存
    saveEvents();
    renderEraBackgrounds();
    
    showInfo('時代区分登録完了', `「${item.label}」の時代区分を登録しました。`);
  }

  // グローバル関数として公開
  window.moveItem = moveItem;
  window.openUrl = openUrl;
  window.openYearWikipedia = openYearWikipedia;
  window.editItem = editItem;
  window.deleteItem = deleteItem;
  window.addNewItem = addNewItem;
  window.saveEditItem = saveEditItem;
  window.addEraFromItem = addEraFromItem;
  window.deleteEraItem = deleteEraItem;

  // ===== 編集UI（テキスト） =====
  function serializeLine(it){ const startYear=(it.startYear||'').trim(); const endYear=(it.endYear||'').trim(); const label=(it.label||'').trim(); const g = Array.isArray(it.genre) ? it.genre.join('・') : (it.genre||'').trim(); const imp=(it.imp===undefined||it.imp===null||String(it.imp)==='')? '' : String(it.imp); const url=(it.url||'').trim(); const note=(it.note||'').trim(); if(!startYear && !endYear && !g && !imp && !url && !note) return label; return [startYear,endYear,label,g,imp,url,note].join(';'); }
  function parseLine(line){ const raw=line.trim(); if(!raw) return null; const parts=raw.split(';'); const startYear=(parts[0]||'').trim(); const endYear=(parts[1]||'').trim(); const label=(parts[2]||'').trim(); if(!label) return null; const genreStr=(parts[3]||'').trim(); let imp=(parts[4]||'').trim(); imp = imp? String(Math.min(5, Math.max(1, parseInt(imp,10)))): ''; const url=(parts[5]||'').trim(); const note=(parts[6]||'').trim(); const o={label}; if(startYear) o.startYear=startYear; if(endYear) { if(endYear.toLowerCase() === 'ongoing') { o.endYear = 'ongoing'; } else { o.endYear = endYear; } } if(genreStr) { const genres = genreStr.split('・').map(g => g.trim().toUpperCase()); o.genre = genres.length > 0 ? genres : [genreStr.toUpperCase()]; } if(imp) o.imp=imp; if(url) o.url=url; if(note) o.note=note; return o; }
  function validateItem(year, it){ const errs=[]; if(it.genre) { const genres = Array.isArray(it.genre) ? it.genre : [it.genre]; for(const genre of genres) { const code=String(genre).toUpperCase(); if(!code){ errs.push(`不正なジャンル: ${genre}`); } } } if(it.imp!==undefined && it.imp!=='' && !(parseInt(it.imp,10)>=1 && parseInt(it.imp,10)<=5)) errs.push(`不正な重要度: ${it.imp}`); if(!(Number.isInteger(year) && year>=YEAR_MIN && year<=YEAR_MAX)) errs.push(`年の範囲外: ${year}`); return errs; }
  function linesFromItems(items){ return items.map(serializeLine).join('\n'); }

  function showEditor(year, anchor){
    clearHighlight(); 
    const all = events[year]||[]; 
    const items = all.filter(passesFilter); 
    const note = (filterGenre||filterImp) ? '（現在のフィルタに一致する項目のみ編集対象）' : '';
    
    editor.innerHTML = `
      <h4><span>${year}年の項目一括編集 ${note}</span><span class="fmt">開始年;終了年;ラベル;ジャンル;重要度;URL;注釈</span></h4>
      <textarea id="edText" placeholder="1行につき1件\n形式：開始年;終了年;ラベル;ジャンル;重要度;URL;注釈\n例）\n1952;1968;鉄腕アトム;MAN;5;https://ja.wikipedia.org/wiki/鉄腕アトム;国民的SFヒーロー\n1983;ongoing;ドラゴンボール;MAN;5;https://ja.wikipedia.org/wiki/ドラゴンボール;継続中のマンガ\n;任天堂ファミコン;GAM;5;https://ja.wikipedia.org/wiki/ファミリーコンピュータ;家庭用ゲーム機の革命\nラベル;;;https://example.com;補足メモ\nラベル"></textarea>
      <div class="row">
        <div class="left">保存でJSONに反映／Ctrl+Enterでも保存・Escで閉じる</div>
        <div class="right">
          <button id="cancel">キャンセル</button>
          <button id="save">保存</button>
        </div>
      </div>`;
    
    const ta=editor.querySelector('#edText'); 
    ta.value = linesFromItems(items);
    
    const r=anchor ? anchor.getBoundingClientRect() : {right: 100, top: 100}; 
    const rv=vp.getBoundingClientRect(); 
    let left = r.right - rv.left + 8; 
    let top = r.top - rv.top; 
    const maxLeft = rv.width - 540; 
    if(left > maxLeft) left = Math.max(12, r.left - rv.left - 540);
    
    editor.style.left = left + 'px'; 
    editor.style.top = top + 'px'; 
    editor.style.display='block';

    function close(){ editor.style.display='none'; }
    editor.querySelector('#cancel').onclick = close;
    editor.querySelector('#save').onclick = ()=>{ 
      const lines = ta.value.split(/\n/).map(s=>s.trim()); 
      const subset = lines.map(parseLine).filter(Boolean); 
      const errs=[]; 
      for(const it of subset){ errs.push(...validateItem(year, it)); } 
      if(errs.length){ showError('編集エラー', errs); return; } 
      const allItems = events[year]||[]; 
      const others = allItems.filter(it=> !passesFilter(it)); 
      const merged = [...others, ...subset]; 
      if(merged.length===0) delete events[year]; 
      else events[year]=merged; 
      saveEvents(); 
      renderEvents(); 
      autoSave(); 
      close(); 
    };
    
    ta.addEventListener('keydown', e=>{ 
      if((e.ctrlKey||e.metaKey) && e.key==='Enter'){ editor.querySelector('#save').click(); } 
      if(e.key==='Escape'){ e.preventDefault(); editor.querySelector('#cancel').click(); } 
    });
  }

  // ===== レンダリング（フィルタ適用・単純クリップ） =====
  function renderEvents(){
    eventsG.innerHTML=''; clearHighlight(true);
    // すべてのハイライトクラスを確実にクリア
    document.querySelectorAll('.hlText').forEach(el => el.classList.remove('hlText'));
    const years = Object.keys(events).map(Number).sort((a,b)=>a-b);
    for(const y of years){
      const ypx=yFromBirthYear(y);
      const labels=(events[y]||[]).filter(passesFilter).map(it=>it.label).filter(Boolean);
      if(labels.length===0){ continue; }
      const yearPart = String(y).slice(2);
      const labelsPart = labels.join('／');
      const fullText = `${yearPart} ${labelsPart}`;
      
      // 表示範囲を計算（左端から右端まで）
      const maxWidth = LABEL_RIGHT_X - LABEL_LEFT_X;
      const charWidth = 10; // 文字幅をより大きく見積もり（安全側に）
      const maxChars = Math.floor(maxWidth / charWidth);
      
      // 年部分は必ず表示し、ラベル部分のみ切り取り（すべて右詰め）
      let text;
      const textX = LABEL_RIGHT_X; // 常に右端
      const textAnchor = 'end'; // 常に右詰め
      
      // より厳密な判定：年部分 + スペース + バッファを考慮
      const yearSpaceLength = yearPart.length + 1; // 年 + スペース
      const buffer = 8; // 余裕を持たせる文字数
      const minRequiredChars = yearSpaceLength + buffer;
      
      // 判定条件：年部分が確実に見えるかどうか
      if (fullText.length > maxChars || minRequiredChars > maxChars || labelsPart.length > 15) {
        // 切り取られた場合も右詰めで表示
        const remainingChars = Math.max(0, maxChars - yearSpaceLength - buffer);
        const truncatedLabels = labelsPart.substring(0, remainingChars);
        text = `${yearPart} ${truncatedLabels}`;
      } else {
        text = fullText;
      }
      
      const tx=textEl(text, textX, ypx, 'eventLabel');
      tx.setAttribute('text-anchor', textAnchor);
      tx.setAttribute('dominant-baseline','middle');
      tx.setAttribute('data-year', y);
      if(labels.length>1) tx.classList.add('eventMulti');
      tx.style.cursor='pointer';
      eventsG.appendChild(tx);
      // クリックで詳細一覧のみ（ホバー時の年別ツールチップは出さない）
      tx.addEventListener('click',(e)=>{ tooltip.style.display='none'; showDetailList(y, e.target); });
    }
  }
  
  try {
    // 起動時はジャンル未選択（ユーザーに選んでもらう）
    selectedGenres = new Set();
    updateGenreFilterButtonText && updateGenreFilterButtonText();
    renderEvents();
    
    // 初期化時に時代区分背景を描画
    renderEraBackgrounds();
  } catch (error) {
    console.error('レンダリングエラー:', error);
  }

  // ===== 検索 =====
  function doSearch(){ 
    clearHighlight(true); 
    const q=searchBox.value.trim(); 
    if(!q){ 
      matches=[]; 
      matchIndex=-1; 
      // 検索ボックスが空の場合はすべてのハイライトをクリア
      document.querySelectorAll('.hlText').forEach(el => el.classList.remove('hlText'));
      return; 
    } 
    
    console.log('検索クエリ:', q);
    console.log('events:', events);
    
    // 検索対象は「選択中ジャンルのラベルのみ」
    const searchResults = [];
    for (const year of Object.keys(events)) {
      const items = events[year] || [];
      for (const item of items) {
        // ジャンルフィルタ
        if (selectedGenres.size === 0) continue;
        if (!itemHasSelectedGenre(item)) continue;
        const labelMatch = item.label && item.label.toLowerCase().includes(q.toLowerCase());
        if (labelMatch) {
          searchResults.push({ year: parseInt(year), item });
          console.log('マッチした項目:', { year, item, labelMatch });
        }
      }
    }
    
    console.log('検索結果:', searchResults);
    
    // 検索結果に基づいてマッチするラベル要素を取得
    const els=[...eventsG.querySelectorAll('text.eventLabel')]; 
    console.log('表示中のラベル要素:', els.length);
    
    matches=els.filter(el=> {
      const year = parseInt(el.getAttribute('data-year'));
      // テキストが省略（トランケート）される場合があるため、
      // 画面表示テキストへの含有判定は行わず、年単位で一致を判定する
      const isMatch = searchResults.some(result => result.year === year);
      if (isMatch) {
        console.log('マッチ（年単位）:', { year, element: el });
      }
      return isMatch;
    });
    
    console.log('最終的なマッチ数:', matches.length);
    
    matchIndex = matches.length? 0 : -1; 
    if(matchIndex!==-1){ highlight(matches[matchIndex]); } 
  }
  function nextMatch(dir){ if(!matches.length) return; matchIndex=(matchIndex+ (dir>0?1:-1) + matches.length)%matches.length; highlight(matches[matchIndex]); }
  searchBtn.addEventListener('click', doSearch);
  searchBox.addEventListener('keydown', e=>{ if(e.key==='Enter'){ doSearch(); }});
  nextBtn.addEventListener('click', ()=> nextMatch(1));
  prevBtn.addEventListener('click', ()=> nextMatch(-1));
  vp.addEventListener('mousemove', ()=>{ if(clearOnNextMove) { clearHighlight(); } });
  vp.addEventListener('click', ()=>{ if(clearOnNextMove) { clearHighlight(); } });

  // ===== 既存ラベル・ジャンル組み合わせ集合 =====
  function buildLabelGenreSet(){ 
    const s=new Set(); 
    for(const y of Object.keys(events)){ 
      for(const it of (events[y]||[])){ 
        if(!it || typeof it.label!=='string') continue;
        // 削除フラグの項目は重複判定から除外
        if (it.deleted === true) continue;
        const genreKey = Array.isArray(it.genre) ? it.genre.slice().sort().join('・') : (it.genre || '');
        const key = `${it.label.trim()}|${genreKey}`;
        s.add(key);
      } 
    } 
    return s; 
  }

  // ===== GitHub同期機能 =====
  let githubUser = null;


  // 設定の保存・読み込み
  function saveGitHubConfig() {
    try {
      localStorage.setItem('githubConfig', JSON.stringify(githubConfig));
    } catch (e) {
      console.error('設定の保存に失敗:', e);
    }
  }

  function loadGitHubConfig() {
    try {
      const saved = localStorage.getItem('githubConfig');
      if (saved) {
        githubConfig = { ...githubConfig, ...JSON.parse(saved) };
      }
    } catch (e) {
      console.error('設定の読み込みに失敗:', e);
    }
  }

  // CSVエクスポート機能（変更・追加・削除のみ）
  function exportToCSV() {
    const csvData = [];
    // 旧項目や削除項目を明示するため deleted 列を付与
    csvData.push('開始年;終了年;ラベル;ジャンル;重要度;URL;注釈;deleted');
    
    let exportCount = 0;
    
    for (const [year, items] of Object.entries(events)) {
      for (const item of items) {
        const startYear = item.startYear || '';
        const endYear = item.endYear || '';
        const label = item.label || '';
        const genre = Array.isArray(item.genre) ? item.genre.join('・') : (item.genre || '');
        const imp = item.imp || '';
        const url = item.url || '';
        const note = item.note || '';
        
        // 1) 通常編集 or 追加: 編集フラグが立っているもの
        const genreKeyForFlag = Array.isArray(item.genre) ? item.genre.slice().sort().join('・') : (item.genre || '');
        const hasEdit = hasEditFlag(year, item.label, genreKeyForFlag);
        if (hasEdit) {
          // 現行（新/編集）データは deleted 空欄
          csvData.push(`${startYear};${endYear};${label};${genre};${imp};${url};${note};`);
          exportCount++;
        }
      }
    }
    // 2) 削除・旧識別子の出力（deleted=trueは付けず、旧内容を行として出力）
    for (const rec of (deletionRecords || [])) {
      const startYear = rec.startYear || '';
      const endYear = rec.endYear || '';
      const label = rec.label || '';
      const genre = rec.genre || '';
      const imp = rec.imp || '';
      const url = rec.url || '';
      const note = rec.note || '';
      // 旧/削除データは deleted=true を付ける
      csvData.push(`${startYear};${endYear};${label};${genre};${imp};${url};${note};true`);
      exportCount++;
    }
    
    if (exportCount === 0) {
      showInfo('エクスポート結果', '変更・追加・削除された項目がありません。');
      return;
    }
    
    const csvContent = csvData.join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', `xnative_changes_${new Date().toISOString().split('T')[0]}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    showInfo('エクスポート完了', `${exportCount}件の変更・追加・削除をCSVで出力しました。管理者に送信してください。`);
  }

  // GitHubからデータを読み込み
  async function loadFromGitHub() {
    if (!githubConfig.accessToken) {
      // トークンがない場合はCSVエクスポートのオプションを提供
      const hasData = Object.keys(events).length > 0;
      if (hasData) {
        const result = confirm('GitHubアクセストークンが設定されていません。\n\n変更された項目のみをCSVファイルとしてエクスポートして、管理者に送信しますか？\n\n「OK」: CSVファイルをダウンロード\n「キャンセル」: 何もしない');
        if (result) {
          exportToCSV();
        }
      } else {
        showError('設定エラー', 'GitHubアクセストークンが設定されていません。GitHubでログインしてください。');
      }
      return null;
    }

    try {
      const response = await fetch(`https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repo}/contents/${githubConfig.filePath}`, {
        headers: {
          'Authorization': `Bearer ${githubConfig.accessToken}`,
          'Accept': 'application/vnd.github.v3+json'
        },
        cache: 'no-store'
      });

      if (!response.ok) {
        if (response.status === 404) {
          // ファイルが存在しない場合は空のデータを返す
          return {};
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const responseData = await response.json();
      // GitHub APIのBase64データを正しくデコード
      const binaryString = atob(responseData.content);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      const content = new TextDecoder('utf-8').decode(bytes);
      const data = JSON.parse(content);
      
      if (data.events) {
        // 新しい形式（events + eraSettings + genres）
        eraSettings = data.eraSettings || [];
        if (data.genres) { setGenresFromRemote(data.genres); }
        return data.events;
      } else {
        // 古い形式（eventsのみ）
        return data;
      }
    } catch (error) {
      showError('読み込みエラー', `GitHubからの読み込みに失敗しました: ${error.message}`);
      return null;
    }
  }

  // GitHubからデータを読み込み（トークンなし）
  async function loadFromGitHubWithoutToken() {
    try {
      // トークンなしでGitHubのrawファイルに直接アクセス
      const rawUrl = `https://raw.githubusercontent.com/${githubConfig.owner}/${githubConfig.repo}/main/${githubConfig.filePath}`;
      console.log('GitHub raw URL:', rawUrl);
      
      const response = await fetch(rawUrl, { cache: 'no-store' });
      
      if (!response.ok) {
        throw new Error(`GitHub raw file error: ${response.status} ${response.statusText}`);
      }

      const content = await response.text();
      const jsonData = JSON.parse(content);
      
      // ジャンルが更新された可能性があるためフィルタ選択をリセット
      if (jsonData.genres) { setGenresFromRemote(jsonData.genres); }
      
      // 時代区分データを読み込み
      if (jsonData.eraSettings) {
        eraSettings = jsonData.eraSettings;
        console.log('時代区分データを読み込み:', eraSettings.length, '個');
        // 時代区分背景を再描画
        if (typeof drawEraBackgrounds === 'function') {
          drawEraBackgrounds();
        }
      }
      
      return jsonData.events ? jsonData.events : jsonData;
    } catch (error) {
      console.error('GitHub raw fileからのデータ読み込みエラー:', error);
      throw error; // エラーを再スローして上位のcatchで処理
    }
  }

  // GitHubにデータを保存（競合検出・解決機能付き）
  async function saveToGitHub(data, expectedSha = null, retryCount = 0) {
    if (!githubConfig.accessToken) {
      // トークンがない場合はCSVエクスポートのオプションを提供
      const hasData = Object.keys(events).length > 0;
      if (hasData) {
        const result = confirm('GitHubアクセストークンが設定されていません。\n\n変更された項目のみをCSVファイルとしてエクスポートして、管理者に送信しますか？\n\n「OK」: CSVファイルをダウンロード\n「キャンセル」: 何もしない');
        if (result) {
          exportToCSV();
        }
      } else {
        showError('設定エラー', 'GitHubアクセストークンが設定されていません。');
      }
      return false;
    }

    const maxRetries = 3;
    
    try {
      console.log(`saveToGitHub開始 (試行回数: ${retryCount + 1}/${maxRetries + 1})`);
      console.log('保存データサイズ:', JSON.stringify(data).length, 'bytes');
      console.log('期待するSHA:', expectedSha);
      
      // 現在のファイル情報を取得してSHAを確認
      let currentSha = null;
      try {
        console.log('現在のファイルのSHAを取得中...');
        const getResponse = await fetch(`https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repo}/contents/${githubConfig.filePath}`, {
          headers: {
            'Authorization': `Bearer ${githubConfig.accessToken}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        });
        
        if (getResponse.ok) {
          const fileData = await getResponse.json();
          currentSha = fileData.sha;
          console.log('現在のSHA取得成功:', currentSha);
          
          // 期待するSHAと現在のSHAが異なる場合、競合が発生
          if (expectedSha && currentSha !== expectedSha) {
            console.log('競合検出: 期待するSHAと現在のSHAが異なります');
            console.log('期待するSHA:', expectedSha);
            console.log('現在のSHA:', currentSha);
            
            if (retryCount < maxRetries) {
              console.log('競合解決のため再試行します...');
              // 最新データを再取得してマージ処理を再実行
              return await handleConflictAndRetry(data, currentSha, retryCount);
            } else {
              throw new Error('最大再試行回数に達しました。手動で同期してください。');
            }
          }
        } else {
          console.log('SHA取得失敗:', getResponse.status, getResponse.statusText);
        }
      } catch (e) {
        console.log('ファイルが存在しないか、SHAの取得に失敗:', e);
      }

      // UTF-8文字列を正しくBase64エンコード
      console.log('データをBase64エンコード中...');
      const jsonString = JSON.stringify(data, null, 2);
      
      // 保存されるデータの削除フラグ付き項目をチェック
      let savedDeletedItems = [];
      for (const year of Object.keys(data.events || {})) {
        const items = data.events[year] || [];
        for (const item of items) {
          if (item.deleted === true) {
            savedDeletedItems.push({ year, label: item.label, deleted: item.deleted });
          }
        }
      }
      console.log('保存されるデータの削除フラグ付き項目:', savedDeletedItems);
      
      const bytes = new TextEncoder().encode(jsonString);
      
      // 大きな配列の場合は分割して処理
      let binaryString = '';
      const chunkSize = 8192; // 8KBずつ処理
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        binaryString += String.fromCharCode(...chunk);
      }
      
      const content = btoa(binaryString);
      console.log('Base64エンコード完了, サイズ:', content.length, 'bytes');
      
      const body = {
        message: `Update timeline data - ${new Date().toISOString()}`,
        content: content
      };

      // 現在のSHAを追加（競合検出のため）
      if (currentSha) {
        body.sha = currentSha;
        console.log('現在のSHAをリクエストボディに追加');
      }

      console.log('GitHub APIにPUTリクエスト送信中...');
      const response = await fetch(`https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repo}/contents/${githubConfig.filePath}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${githubConfig.accessToken}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(body)
      });

      console.log('GitHub APIレスポンス:', response.status, response.statusText);

      if (!response.ok) {
        const errorData = await response.json();
        console.error('GitHub APIエラー詳細:', errorData);
        
        // 409エラー（競合）の場合の特別処理
        if (response.status === 409) {
          console.log('409エラー: ファイルが他のユーザーによって更新されました');
          if (retryCount < maxRetries) {
            console.log('競合解決のため再試行します...');
            return await handleConflictAndRetry(data, null, retryCount);
          } else {
            throw new Error('他のユーザーが同時に編集しています。しばらく待ってから再度同期してください。');
          }
        }
        
        throw new Error(`HTTP ${response.status}: ${response.statusText} - ${errorData.message || ''}`);
      }

      console.log('saveToGitHub完了');
      return true;
    } catch (error) {
      console.error('saveToGitHubエラー詳細:', error);
      if (retryCount < maxRetries && error.message.includes('競合')) {
        console.log('競合エラーのため再試行します...');
        return await handleConflictAndRetry(data, null, retryCount);
      }
      showError('保存エラー', `GitHubへの保存に失敗しました: ${error.message}`);
      return false;
    }
  }
  
  // 競合発生時の再試行処理
  async function handleConflictAndRetry(originalData, newSha, retryCount) {
    console.log('競合解決処理開始');
    
    try {
      // 最新のリモートデータを再取得
      console.log('最新のリモートデータを再取得中...');
      const latestRemoteData = await loadFromGitHub();
      if (latestRemoteData === null) {
        throw new Error('最新データの取得に失敗しました');
      }
      
      // より詳細なマージ処理を実行
      const { merged: mergedAfterResolve, conflicts } = await performDetailedMerge(events, latestRemoteData);
      
      // 再試行（マージ済みデータのみ保存）
      const ok = await saveToGitHub(mergedAfterResolve, newSha, retryCount + 1);
      if (!ok) return false;
      
      // 保存成功時はローカル状態にも反映して、競合通知を表示
      events = mergedAfterResolve;
      saveEvents();
      renderEvents();
      if (conflicts && conflicts.length) {
        showConflictNotification(conflicts);
      }
      return true;
    } catch (error) {
      console.error('競合解決処理エラー:', error);
      
      // 競合エラーの場合は詳細な競合情報を表示
      if (error instanceof ConflictError) {
        showConflictNotification(error.conflicts);
        return false;
      }
      
      showError('競合解決エラー', `競合の解決に失敗しました: ${error.message}`);
      return false;
    }
  }

  // 競合通知を表示（自動解決後）
  function showConflictNotification(conflicts) {
    console.log('競合通知:', conflicts);
    
    let conflictHtml = '<h4>編集競合が検出されました</h4>';
    conflictHtml += '<p>以下の項目について、編集が競合したため新たに同期してからやりなおしてください。</p>';
    
    let hasNoteConflicts = false;
    let hasOtherConflicts = false;
    
    conflicts.forEach((conflict, index) => {
      const noteConflict = conflict.conflictFields.find(cf => cf.field === 'note');
      const impConflict = conflict.conflictFields.find(cf => cf.field === 'imp');
      const urlConflict = conflict.conflictFields.find(cf => cf.field === 'url');
      const hasNoteConflict = noteConflict && noteConflict.localValue !== noteConflict.remoteValue;
      const hasImpConflict = impConflict && impConflict.localValue !== impConflict.remoteValue;
      const hasUrlConflict = urlConflict && urlConflict.localValue !== urlConflict.remoteValue;
      
      if (hasNoteConflict) hasNoteConflicts = true;
      if (hasImpConflict || hasUrlConflict) hasOtherConflicts = true;
      
      conflictHtml += `
        <div style="border: 1px solid #f44336; margin: 12px 0; padding: 12px; border-radius: 6px; background: #ffebee;">
          <h5 style="margin: 0 0 8px 0; color: #d32f2f;">${conflict.year}年: ${conflict.label}${conflict.genre ? ` [${conflict.genre}]` : ''}</h5>
          <div style="margin: 8px 0; padding: 8px; background: #ffcdd2; border-radius: 4px;">
            <strong style="color: #d32f2f;">編集が競合したため新たに同期してからやりなおしてください</strong>
          </div>
        </div>
      `;
    });
    
    // 注意メッセージ
    conflictHtml += `
      <div style="margin-top: 16px; padding: 12px; background: #fff3e0; border: 1px solid #ff9800; border-radius: 6px;">
        <h6 style="margin: 0 0 8px 0; color: #f57c00;">注意</h6>
        <p style="margin: 0; font-size: 14px; color: #f57c00;">
          競合した項目は他のユーザーの編集内容に設定されました。<br>
          再度同期してから編集をやりなおしてください。
        </p>
      </div>
    `;
    
    // モーダルを開く（自動で閉じないようにする）
    openModal('競合エラー', conflictHtml);
  }
  
  // アイテムの詳細をフォーマット
  function formatItemDetails(item) {
    let details = [];
    if (item.label) details.push(`<strong>ラベル:</strong> ${item.label}`);
    if (item.genre) details.push(`<strong>ジャンル:</strong> ${item.genre}`);
    if (item.imp) details.push(`<strong>重要度:</strong> ${item.imp}`);
    if (item.url) details.push(`<strong>URL:</strong> ${item.url}`);
    if (item.note) details.push(`<strong>注釈:</strong> ${item.note}`);
    
    return details.length > 0 ? details.join('<br>') : '<em>データなし</em>';
  }
  
  // 詳細なマージ処理（真の競合のみ検出）
  async function performDetailedMerge(localData, remoteData) {
    console.log('詳細マージ処理開始');
    console.log('ローカルデータ:', localData);
    console.log('リモートデータ:', remoteData);
    
    const merged = { ...remoteData };
    const conflicts = []; // 真の競合のみを記録
    
    // 各年のデータを詳細にマージ
    const getGenreKey = (g)=> Array.isArray(g) ? g.slice().sort().join('・') : (g || '');
    const getYearVal = (it, fallbackYear) => (it && typeof it.startYear === 'number') ? it.startYear : fallbackYear;
    const makeKey = (it, fallbackYear) => `${it.label}|${getGenreKey(it.genre)}|${getYearVal(it, fallbackYear)}`;

    for (const [year, localItems] of Object.entries(localData)) {
      if (!merged[year]) {
        merged[year] = [];
      }
      
      const remoteItems = merged[year] || [];
      const localItemMap = new Map();
      const remoteItemMap = new Map();
      
      // ローカルアイテムをマップ化（年もキーに含め、ジャンルは正規化）
      localItems.forEach(item => {
        const key = makeKey(item, parseInt(year,10));
        localItemMap.set(key, item);
      });
      
      // リモートアイテムをマップ化
      remoteItems.forEach(item => {
        const key = makeKey(item, parseInt(year,10));
        remoteItemMap.set(key, item);
      });
      
      const mergedItems = [];
      const processedKeys = new Set();
      
      // ローカルアイテムを処理
      for (const [key, localItem] of localItemMap) {
        const remoteItem = remoteItemMap.get(key);
        
        if (remoteItem) {
          // 両方に存在する場合：編集フラグをチェック
          const hasLocalEdit = hasEditFlag(getYearVal(localItem, parseInt(year,10)), localItem.label, getGenreKey(localItem.genre));
          
          if (hasLocalEdit) {
            // ローカルで編集されている場合のみ競合をチェック
            const conflictInfo = checkRealConflict(localItem, remoteItem);
            if (conflictInfo.hasConflict) {
              conflicts.push({
                year: year,
                label: localItem.label,
                genre: localItem.genre || '',
                localItem: localItem,
                remoteItem: remoteItem,
                conflictFields: conflictInfo.conflictFields
              });
              
              // 真の競合がある場合は自動解決を実行
              const resolvedItem = resolveConflict(localItem, remoteItem, conflictInfo);
              mergedItems.push(resolvedItem);
            } else {
              // 競合がない場合はローカルの項目を保持
              mergedItems.push(localItem);
            }
          } else {
            // ローカルで編集されていない場合はリモートの項目を採用
            console.log('ローカルで編集されていないため、リモートの項目を採用:', localItem.label);
            mergedItems.push(remoteItem);
          }
        } else {
          // ローカルのみに存在する場合（新規 or 旧レコードのdeleted）
          mergedItems.push(localItem);
        }
        processedKeys.add(key);
      }
      
      // リモートのみに存在するアイテムを追加
      for (const [key, remoteItem] of remoteItemMap) {
        if (!processedKeys.has(key)) {
          mergedItems.push(remoteItem);
        }
      }
      
      merged[year] = mergedItems;
    }
    
    console.log('詳細マージ処理完了:', merged);
    return { merged, conflicts };
  }
  
  // 真の競合をチェック（他のユーザーによる変更のみ）
  function checkRealConflict(localItem, remoteItem) {
    const fields = ['label', 'genre', 'imp', 'url', 'note', 'startYear', 'endYear'];
    const conflictFields = [];
    
    for (const field of fields) {
      const localValue = localItem[field] || '';
      const remoteValue = remoteItem[field] || '';
      
      // 注釈フィールドの特別処理
      if (field === 'note') {
        if (isRealNoteConflict(localValue, remoteValue)) {
          console.log(`真の競合検出: ${field} フィールドが異なります`);
          console.log(`ローカル: "${localValue}"`);
          console.log(`リモート: "${remoteValue}"`);
          conflictFields.push({
            field: field,
            localValue: localValue,
            remoteValue: remoteValue
          });
        }
      } else {
        // その他のフィールドは従来通り
        // ただし、空文字列とundefinedの違いは競合としない
        let localNormalized = localValue === '' ? undefined : localValue;
        let remoteNormalized = remoteValue === '' ? undefined : remoteValue;
        if (field === 'genre') {
          localNormalized = Array.isArray(localValue) ? localValue.slice().sort().join('・') : (localValue || undefined);
          remoteNormalized = Array.isArray(remoteValue) ? remoteValue.slice().sort().join('・') : (remoteValue || undefined);
        }
        
        if (localNormalized !== remoteNormalized) {
          console.log(`真の競合検出: ${field} フィールドが異なります`);
          console.log(`ローカル: "${localValue}"`);
          console.log(`リモート: "${remoteValue}"`);
          conflictFields.push({
            field: field,
            localValue: localValue,
            remoteValue: remoteValue
          });
        }
      }
    }
    
    return {
      hasConflict: conflictFields.length > 0,
      conflictFields: conflictFields
    };
  }
  
  // 真の注釈競合をチェック（追記による変更は競合としない）
  function isRealNoteConflict(localNote, remoteNote) {
    if (!localNote && !remoteNote) return false;
    if (!localNote && remoteNote) return false; // ローカルに注釈がなく、リモートにある場合は競合ではない
    if (localNote && !remoteNote) return false; // ローカルに注釈があり、リモートにない場合は競合ではない
    if (localNote === remoteNote) return false;
    
    // リモートの注釈を解析
    const remoteLines = remoteNote.split('\n');
    const hasAppendMarker = remoteLines.some(line => line.trim().startsWith('[追記]'));
    
    if (hasAppendMarker) {
      // 追記マーカーがある場合、元の内容と追記内容を分離
      const originalContent = remoteLines[0].trim();
      const appendLines = remoteLines.slice(1).map(line => {
        return line.trim().replace(/^\[追記\]\s*/, '');
      }).filter(line => line.length > 0);
      
      const localTrimmed = localNote.trim();
      
      // ローカルの内容が元の内容と同じ場合は競合としない
      if (originalContent === localTrimmed) {
        return false;
      }
      
      // ローカルの内容が追記内容に含まれている場合は競合としない
      const isInAppendLines = appendLines.some(appendLine => {
        return appendLine === localTrimmed;
      });
      
      if (isInAppendLines) {
        return false;
      }
    } else {
      // 追記マーカーがない場合、単純な重複チェック
      const localTrimmed = localNote.trim();
      const remoteTrimmed = remoteNote.trim();
      
      if (localTrimmed === remoteTrimmed) {
        return false;
      }
    }
    
    return true;
  }
  
  // 注釈の競合をチェック（追記済みの場合は競合としない）
  function isNoteConflict(localNote, remoteNote) {
    if (!localNote && !remoteNote) return false;
    if (!localNote || !remoteNote) return true;
    if (localNote === remoteNote) return false;
    
    // ローカルの注釈がリモートの注釈に既に含まれているかチェック
    const localTrimmed = localNote.trim();
    const remoteLines = remoteNote.split('\n');
    
    // リモートの各行から[追記]プレフィックスを除去して比較
    const remoteContentLines = remoteLines.map(line => {
      return line.trim().replace(/^\[追記\]\s*/, '');
    });
    
    // ローカルの内容がリモートに既に含まれている場合は競合としない
    const isAlreadyIncluded = remoteContentLines.some(remoteContent => {
      return remoteContent === localTrimmed;
    });
    
    if (isAlreadyIncluded) {
      console.log('ローカルの注釈は既にリモートに含まれているため競合としない:', localNote);
      return false;
    }
    
    return true;
  }
  
  // 競合を自動解決
  function resolveConflict(localItem, remoteItem, conflictInfo) {
    console.log('競合自動解決開始:', localItem.label);
    
    // 基本構造はリモートをベースにする
    const resolved = { ...remoteItem };
    
    // 重要度とURLは変更されない（リモートの値を保持）
    // 注釈は追記される（ただし重複を避ける）
    const noteConflict = conflictInfo.conflictFields.find(cf => cf.field === 'note');
    if (noteConflict) {
      const localNote = noteConflict.localValue;
      const remoteNote = noteConflict.remoteValue;
      
      if (localNote && remoteNote && localNote !== remoteNote) {
        // 両方に注釈がある場合：重複チェックして追記
        resolved.note = appendNoteSafely(remoteNote, localNote);
        console.log('注釈を安全に追記:', resolved.note);
      } else if (localNote && !remoteNote) {
        // ローカルのみに注釈がある場合は追加
        resolved.note = localNote;
        console.log('注釈を追加:', resolved.note);
      }
      // リモートのみに注釈がある場合はそのまま保持
    }
    
    console.log('競合解決完了:', resolved);
    return resolved;
  }
  
  // 注釈を安全に追記（重複を避ける）
  function appendNoteSafely(existingNote, newNote) {
    if (!existingNote) return newNote;
    if (!newNote) return existingNote;
    
    // 既存の注釈を解析
    const existingLines = existingNote.split('\n');
    const hasAppendMarker = existingLines.some(line => line.trim().startsWith('[追記]'));
    
    // 新しい注釈が既に存在するかチェック
    const newNoteTrimmed = newNote.trim();
    
    if (hasAppendMarker) {
      // 追記マーカーがある場合、元の内容と追記内容を分離してチェック
      const originalContent = existingLines[0].trim();
      const appendLines = existingLines.slice(1).map(line => {
        return line.trim().replace(/^\[追記\]\s*/, '');
      }).filter(line => line.length > 0);
      
      // 元の内容と同じかチェック
      if (originalContent === newNoteTrimmed) {
        console.log('新しい注釈が元の内容と同じため追記をスキップ:', newNote);
        return existingNote;
      }
      
      // 追記内容に含まれているかチェック
      const alreadyInAppend = appendLines.some(appendLine => {
        return appendLine === newNoteTrimmed;
      });
      
      if (alreadyInAppend) {
        console.log('新しい注釈が追記内容に既に存在するため追記をスキップ:', newNote);
        return existingNote;
      }
    } else {
      // 追記マーカーがない場合、単純な重複チェック
      const existingTrimmed = existingNote.trim();
      if (existingTrimmed === newNoteTrimmed) {
        console.log('新しい注釈が既存の内容と同じため追記をスキップ:', newNote);
        return existingNote;
      }
    }
    
    // 新しい注釈を追記
    return `${existingNote}\n[追記] ${newNote}`;
  }
  
  // 競合エラークラス
  class ConflictError extends Error {
    constructor(message, conflicts) {
      super(message);
      this.name = 'ConflictError';
      this.conflicts = conflicts;
    }
  }

  // 同期処理（確認ダイアログなし）
  async function syncWithConfirmation() {
    await syncWithGitHub();
  }

  // 同期処理（競合検出・解決機能付き）
  async function syncWithGitHub() {
    try {
      console.log('同期処理開始');
      console.log('同期開始時のeraSettings:', eraSettings);
      console.log('同期開始時のeraSettingsの長さ:', eraSettings ? eraSettings.length : 0);
      console.log('ローカルデータサイズ:', JSON.stringify(events).length, 'bytes');
      
      // 1. GitHubからデータを読み込み（SHAハッシュも同時に取得）
      console.log('GitHubからデータを読み込み中...');
      const { remoteData, remoteSha, remoteEraSettings, timestamp } = await loadFromGitHubWithSha();
      if (remoteData === null) {
        console.log('リモートデータの読み込みに失敗');
        return;
      }

      // ローカルデータの削除フラグ付き項目をチェック
      let localDeletedItems = [];
      for (const year of Object.keys(events)) {
        const items = events[year] || [];
        for (const item of items) {
          if (item.deleted === true) {
            localDeletedItems.push({ year, label: item.label, deleted: item.deleted });
          }
        }
      }
      
      console.log('同期開始 - リモートデータ:', remoteData);
      console.log('同期開始 - ローカルデータ:', events);
      console.log('同期開始 - ローカル削除フラグ付き項目:', localDeletedItems);
      console.log('同期開始 - リモートeraSettings:', remoteEraSettings);
      console.log('同期開始 - ローカルeraSettings:', eraSettings);
      console.log('同期開始 - リモートSHA:', remoteSha);
      console.log('同期開始 - リモートタイムスタンプ:', timestamp);

      // 2. 要注意モードかどうかを判定
      const cautionMode = isCautionMode(timestamp);
      console.log('同期モード:', cautionMode ? '要注意モード' : '通常モード');

      // 3. 順序変更フラグをチェック
      const localData = events;
      let mergeResult;
      
      if (getOrderChanged()) {
        // 順序変更がある場合は、ローカルの順序を強制反映してフラグをオフ
        console.log('順序変更が検出されたため、ローカルの順序を強制反映');
        setOrderChanged(false); // フラグをオフ
        mergeResult = { merged: localData, conflicts: [] };
      } else if (cautionMode) {
        // 要注意モードでの同期処理
        mergeResult = performCautionModeSync(localData, remoteData);
      } else {
        // 通常モードでの同期処理
        mergeResult = performNormalModeSync(localData, remoteData);
      }
      
      const merged = mergeResult.merged;
      const conflicts = mergeResult.conflicts;

      // マージ後データの削除フラグ付き項目をチェック
      let mergedDeletedItems = [];
      for (const year of Object.keys(merged)) {
        const items = merged[year] || [];
        for (const item of items) {
          if (item.deleted === true) {
            mergedDeletedItems.push({ year, label: item.label, deleted: item.deleted });
          }
        }
      }
      
      console.log('同期完了 - マージ後データ:', merged);
      console.log('同期完了 - マージ後削除フラグ付き項目:', mergedDeletedItems);
      console.log('同期完了 - 競合情報:', conflicts);
      console.log('マージ後データサイズ:', JSON.stringify(merged).length, 'bytes');

      // 3. eraSettingsのマージ処理（要件準拠）
      console.log('eraSettings同期前:', { 
        local: eraSettings, 
        localLength: eraSettings ? eraSettings.length : 0,
        windowEraSettings: window.eraSettings,
        windowLength: window.eraSettings ? window.eraSettings.length : 0,
        remote: remoteEraSettings, 
        remoteLength: remoteEraSettings.length 
      });
      
      // 仕様:
      // ・ローカルにある時代区分名がリモートにあれば、リモートのその時代区分をローカルで上書き
      // ・ローカルにあるがリモートにない時代区分は何もしない（ローカル保持、リモートに保存しない）
      // ・ローカルにない時代区分でリモートにあるものはローカルへ取り込み
      const localBase = (window.eraSettings && window.eraSettings.length > 0) ? window.eraSettings : (eraSettings || []);
      const remoteBase = remoteEraSettings || [];
      const nameToRemote = new Map(remoteBase.map(e => [String(e.name||''), e]));
      const nameToLocal  = new Map(localBase.map(e => [String(e.name||''), e]));
      const mergedEraSettings = [];
      const toSaveEraSettings = []; // リモートに保存する時代区分（ローカルにないリモート分のみ）
      const seen = new Set();
      // ローカル基準に反映（上書き or そのまま）
      for (const loc of localBase){
        const key = String(loc.name||'');
        if (!key){ continue; }
        if (nameToRemote.has(key)){
          // 同名があれば、リモートの項目をローカルの値で上書き（ローカル優先）
          const remoteEra = nameToRemote.get(key);
          const mergedEra = { ...remoteEra, ...loc };
          mergedEraSettings.push(mergedEra);
          toSaveEraSettings.push(mergedEra); // リモートに保存
        } else {
          // リモートに無い時代区分はそのまま保持
          mergedEraSettings.push(loc);
          // リモートに保存しない（ローカルのみ保持）
        }
        seen.add(key);
      }
      // ローカルにないがリモートにある分を追加
      for (const rem of remoteBase){
        const key = String(rem.name||'');
        if (!key || seen.has(key)) continue;
        mergedEraSettings.push(rem);
        toSaveEraSettings.push(rem); // リモートに保存
      }
      console.log('eraSettings同期後:', { 
        merged: mergedEraSettings, 
        mergedLength: mergedEraSettings.length 
      });

      // 4. マージしたデータを保存（期待するSHAを指定）
      console.log('GitHubにデータを保存中...');
      const dataToSave = {
        events: merged,
        eraSettings: toSaveEraSettings, // リモートに保存するのは同名上書き分と新規取り込み分のみ
        genres: GENRES.map(code=>({code, label: (GENRE_LABELS && GENRE_LABELS[code]) ? GENRE_LABELS[code] : code}))
      };
      console.log('保存するデータ構造:', {
        hasEvents: !!dataToSave.events,
        eventsKeys: Object.keys(dataToSave.events || {}),
        hasEraSettings: !!dataToSave.eraSettings,
        eraSettingsLength: dataToSave.eraSettings.length,
        eraSettingsContent: dataToSave.eraSettings
      });
      const success = await saveToGitHub(dataToSave, remoteSha);
      if (success) {
        events = merged;
        
        // eraSettingsを確実にローカルに反映
        eraSettings = mergedEraSettings;
        window.eraSettings = mergedEraSettings;
        
        console.log('同期完了後のeraSettings:', eraSettings);
        console.log('同期完了後のwindow.eraSettings:', window.eraSettings);
        
        saveEvents();
        console.log('saveEvents後のeraSettings確認:', eraSettings);
        renderEvents();
        renderEraBackgrounds();
        
        // 同期完了時刻を記録
        localStorage.setItem('lastSync', new Date().toISOString());
        lastSavedEventsData = JSON.stringify(events); // 自動保存の基準を更新
        updateSyncStatus();
        
        // データ鮮度時刻を更新
        setDataFreshnessTimestamp(timestamp);
        
        // 編集フラグ・削除記録・バックアップをクリア
        clearEditFlags();
        clearDeletionRecords();
        clearLabelBackups();
        
        // 競合があった場合は競合通知を表示、なければ通常の完了メッセージを表示
        if (conflicts.length > 0) {
          showConflictNotification(conflicts);
        } else {
          showInfo('同期完了', 'GitHubとの同期が完了しました。');
        }
        console.log('同期処理完了');
      } else {
        console.log('GitHubへの保存に失敗');
      }
    } catch (error) {
      console.error('同期エラーの詳細:', error);
      
      // 競合エラーの場合は詳細な競合情報を表示
      if (error instanceof ConflictError) {
        showConflictNotification(error.conflicts);
        return;
      }
      
      showError('同期エラー', `同期処理でエラーが発生しました: ${error.message}`);
    }
  }
  
  // GitHubからデータとSHAハッシュを同時に取得
  async function loadFromGitHubWithSha() {
    if (!githubConfig.accessToken) {
      // トークンがない場合はCSVエクスポートのオプションを提供
      const hasData = Object.keys(events).length > 0;
      if (hasData) {
        const result = confirm('GitHubアクセストークンが設定されていません。\n\n変更された項目のみをCSVファイルとしてエクスポートして、管理者に送信しますか？\n\n「OK」: CSVファイルをダウンロード\n「キャンセル」: 何もしない');
        if (result) {
          exportToCSV();
        }
      } else {
        showError('設定エラー', 'GitHubアクセストークンが設定されていません。GitHubでログインしてください。');
      }
      return { remoteData: null, remoteSha: null, remoteEraSettings: [], timestamp: null };
    }

    try {
      const response = await fetch(`https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repo}/contents/${githubConfig.filePath}`, {
        headers: {
          'Authorization': `Bearer ${githubConfig.accessToken}`,
          'Accept': 'application/vnd.github.v3+json'
        },
        cache: 'no-store'
      });

      if (!response.ok) {
        if (response.status === 404) {
          // ファイルが存在しない場合は空のデータを返す
          return { remoteData: {}, remoteSha: null, remoteEraSettings: [] };
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const responseData = await response.json();
      const sha = responseData.sha;
      
      // GitHub APIのBase64データを正しくデコード
      const binaryString = atob(responseData.content);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      const content = new TextDecoder('utf-8').decode(bytes);
      const data = JSON.parse(content);
      
      // タイムスタンプを取得
      const timestamp = responseData.last_modified || new Date().toISOString();
      
      if (data.events) {
        // 新しい形式（events + eraSettings）
        return { 
          remoteData: data.events, 
          remoteSha: sha, 
          remoteEraSettings: data.eraSettings || [],
          timestamp: timestamp
        };
      } else {
        // 古い形式（eventsのみ）
        return { 
          remoteData: data, 
          remoteSha: sha, 
          remoteEraSettings: [],
          timestamp: timestamp
        };
      }
    } catch (error) {
      showError('読み込みエラー', `GitHubからの読み込みに失敗しました: ${error.message}`);
      return { remoteData: null, remoteSha: null, remoteEraSettings: [], timestamp: null };
    }
  }

  // 設定画面
  function showSettings() {
    console.log('showSettings called');
    const settingsHtml = `
      <h4>GitHub同期設定</h4>
      <p>管理者から提供された設定情報を入力してください。</p>
      <div style="margin: 16px 0;">
        <label style="display: block; margin-bottom: 8px;">
          <strong>Personal Access Token:</strong><br>
          <small style="color: #666;">管理者から提供されたトークンを入力</small><br>
          <input type="password" id="accessToken" value="${githubConfig.accessToken}" 
                 style="width: 100%; padding: 6px; margin-top: 4px;" 
                 placeholder="管理者から提供されたトークンを入力" />
        </label>
        <label style="display: block; margin-bottom: 8px;">
          <strong>リポジトリ所有者:</strong><br>
          <small style="color: #666;">通常は「hortense667」</small><br>
          <input type="text" id="owner" value="${githubConfig.owner || 'hortense667'}" 
                 style="width: 100%; padding: 6px; margin-top: 4px;" 
                 placeholder="hortense667" />
        </label>
        <label style="display: block; margin-bottom: 8px;">
          <strong>リポジトリ名:</strong><br>
          <small style="color: #666;">通常は「xnative」</small><br>
          <input type="text" id="repo" value="${githubConfig.repo || 'xnative'}" 
                 style="width: 100%; padding: 6px; margin-top: 4px;" 
                 placeholder="xnative" />
        </label>
        <label style="display: block; margin-bottom: 8px;">
          <strong>ファイルパス:</strong><br>
          <small style="color: #666;">通常は「timeline_popculture_02.json」</small><br>
          <input type="text" id="filePath" value="${githubConfig.filePath || 'timeline_popculture_02.json'}" 
                 style="width: 100%; padding: 6px; margin-top: 4px;" 
                 placeholder="timeline_popculture_02.json" />
        </label>
        <div style="margin: 12px 0; padding: 8px; background: #f0f8ff; border: 1px solid #b3d9ff; border-radius: 6px; font-size: 12px;">
          <strong>URLパラメータでの指定:</strong><br>
          <code>?owner=ユーザー名&repo=リポジトリ名&filePath=ファイルパス</code><br>
          <small style="color: #666;">例: ?owner=hortense667&repo=xnative&filePath=timeline_popculture_02.json</small>
        </div>
      </div>
      <div style="margin: 16px 0; padding: 12px; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 6px;">
        <h5>設定情報について:</h5>
        <p style="margin: 8px 0; font-size: 14px;">
          <strong>一般ユーザー:</strong> 管理者（hortense667）から提供された設定情報を入力してください。<br>
          <strong>管理者:</strong> 新しいトークンを生成する場合は、<a href="https://github.com/settings/tokens" target="_blank">GitHub Personal Access Tokens</a>で「repo」スコープを選択してトークンを生成してください。
        </p>
      </div>
      <div style="margin: 16px 0; padding: 12px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 6px;">
        <h5>データ管理</h5>
        <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-bottom: 8px;">
          <button class="btn" id="settingsLoadCsvBtn" title="CSV/TSVを読み込んで追加" onclick="settingsLoadCsv()">ロード</button>
          <p style="margin: 0; font-size: 12px; color: #856404;">
            ロードはデータを一括登録する機能です。詳しい使い方はユーザーガイドをご覧ください。文字コードは必ず「UTF-8」にしてください。また、通常、 timeline_popculture_02.jsonとなっている「ファイルパス」をtimeline-test.jsonに変更して正しくロードされるか確認してからtimeline_popculture_02.jsonにロードするようにしてください。
          </p>
        </div>
        <p style="margin: 8px 0; font-size: 12px; color: #856404;">
          注意: この操作は現在表示されているすべてのデータを削除し、GitHubから最新データを読み込みます。
        </p>
        <button class="btn" onclick="clearAllDataAndReload()" style="background: #dc3545; color: white; border-color: #dc3545;">
          表示中の全ラベルをクリアしてGitHubから読み込み
        </button>
      </div>
      <div style="text-align: right; margin-top: 16px;">
        <button class="btn" onclick="closeModal()">キャンセル</button>
        <button class="btn" onclick="saveSettings()" style="margin-left: 8px;">保存</button>
      </div>
    `;
    openModal('設定', settingsHtml);
  }

  async function saveSettings() {
    const tokenInput = document.getElementById('accessToken');
    const ownerInput = document.getElementById('owner');
    const repoInput = document.getElementById('repo');
    const pathInput = document.getElementById('filePath');
    
    if (tokenInput && ownerInput && repoInput && pathInput) {
      const prevFilePath = githubConfig.filePath || 'timeline_popculture_02.json';
      githubConfig.accessToken = tokenInput.value.trim();
      githubConfig.owner = ownerInput.value.trim();
      githubConfig.repo = repoInput.value.trim();
      githubConfig.filePath = (pathInput.value.trim() || 'timeline_popculture_02.json');
      saveGitHubConfig();
      // URLのfilePath等も同期
      try{
        const params = new URLSearchParams(window.location.search);
        if(githubConfig.owner) params.set('owner', githubConfig.owner); else params.delete('owner');
        if(githubConfig.repo) params.set('repo', githubConfig.repo); else params.delete('repo');
        if(githubConfig.filePath) params.set('filePath', githubConfig.filePath); else params.delete('filePath');
        const newUrl = `${window.location.pathname}?${params.toString()}`;
        window.history.replaceState(null, '', newUrl);
      }catch(e){ console.warn('URL更新に失敗:', e); }
      const filePathChanged = prevFilePath !== githubConfig.filePath;
      closeModal();
      showInfo('設定保存', '設定が保存されました。');
    if (filePathChanged) {
      // URLのfilePath等も同期
      try{
        const params = new URLSearchParams(window.location.search);
        if(githubConfig.owner) params.set('owner', githubConfig.owner); else params.delete('owner');
        if(githubConfig.repo) params.set('repo', githubConfig.repo); else params.delete('repo');
        if(githubConfig.filePath) params.set('filePath', githubConfig.filePath); else params.delete('filePath');
        const newUrl = `${window.location.pathname}?${params.toString()}`;
        window.history.replaceState(null, '', newUrl);
      }catch(e){ console.warn('URL更新に失敗:', e); }
        try { await clearAllDataAndReload(); } catch (e) { console.error(e); }
      }
    }
  }

  // 設定画面内のロード処理
  async function settingsLoadCsv() {
    const pathInput = document.getElementById('filePath');
    const newPath = (pathInput && pathInput.value ? pathInput.value.trim() : '') || 'timeline_popculture_02.json';
    const prevFilePath = githubConfig.filePath || 'timeline_popculture_02.json';
    const filePathChanged = newPath !== prevFilePath;
    if (filePathChanged) {
      githubConfig.filePath = newPath;
      saveGitHubConfig();
      try { await clearAllDataAndReload(); } catch (e) { console.error(e); }
    }
    // 既存のロード処理（CSV/TSV選択）
    const fileInputEl = document.getElementById('fileInput');
    if (fileInputEl) fileInputEl.click();
  }
  
  // 全データをクリアしてGitHubから読み込み
  async function clearAllDataAndReload(options = {}) {
    const requireConfirm = options.requireConfirm !== false;
    const githubOnly = options.githubOnly === true;
    if (requireConfirm && !confirm('すべてのデータを削除してGitHubから最新データを読み込みますか？\nこの操作は取り消せません。')) {
      return;
    }
    
    try {
      // 1. 現在のローカル状態と保存データを完全クリア
      events = {};
      eraSettings = [];
      deletionRecords = [];
      labelBackups = {};
      editFlags = {};
      // localStorageから関連キーを削除
      try {
        localStorage.removeItem('timelineEventsV2');
        localStorage.removeItem('timelineEventsV1');
        localStorage.removeItem('autoSave');
        localStorage.removeItem('lastEdit');
        localStorage.removeItem('xnative_deletions');
        localStorage.removeItem('xnative_label_backups');
        localStorage.removeItem('xnative_edit_flags');
        localStorage.removeItem('xnative_data_freshness');
      } catch(e) { console.warn('ローカルデータ削除時の警告:', e); }
      // UIを即座に空状態へ
      renderEvents();
      if (typeof drawEraBackgrounds === 'function') { drawEraBackgrounds(); }
      // フィルタは全選択に初期化
      if (window.selectedGenres) { selectedGenres = new Set(GENRES); }
      if (typeof updateGenreFilterButtonText === 'function') { updateGenreFilterButtonText(); }
      
      // 2. GitHubから最新データを読み込み（トークンがなくても読み込み）
      let remoteData = null;
      
      // トークンが設定されていなくてもGitHubから読み込みを試行
      console.log('GitHubから読み込み開始（トークン:', githubConfig.accessToken ? '設定済み' : '未設定', '）');
      
      try {
        // まずGitHubから読み込みを試行
        remoteData = await loadFromGitHubWithoutToken();
        console.log('GitHubからの読み込み成功');
      } catch (e) {
        if (githubOnly) {
          throw new Error(`GitHubからの読み込みに失敗しました: ${e.message}`);
        }
        console.log('GitHubからの読み込み失敗、埋め込みJSONから読み込み:', e.message);
        
        // GitHubからの読み込みに失敗した場合は埋め込みJSONから読み込み
        try {
          const eventsJsonElement = document.getElementById('events-json');
          if (!eventsJsonElement) {
            throw new Error('events-json要素が見つかりません');
          }
          
          // innerHTMLを使用してより安全にJSONを取得
          const txt = eventsJsonElement.innerHTML.trim();
          console.log('埋め込みJSONテキスト長:', txt.length);
          console.log('埋め込みJSONテキスト（最後の50文字）:', txt.slice(-50));
          
          // 文字コードを確認
          const lastChars = txt.slice(-10);
          console.log('最後の10文字の文字コード:', Array.from(lastChars).map(c => c.charCodeAt(0)));
          
          // 問題のある文字を特定
          const problematicChars = txt.match(/[^\x20-\x7E\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g);
          if (problematicChars) {
            console.log('問題のある文字:', problematicChars);
          }
          
          const embedded = JSON.parse(txt);
          console.log('埋め込みJSON解析成功:', Object.keys(embedded).length, '個の年');
          
          // 時代区分データを読み込み
          if (embedded.eraSettings) {
            eraSettings = embedded.eraSettings;
            console.log('埋め込みJSONから時代区分データを読み込み:', eraSettings.length, '個');
            // 時代区分背景を再描画
            if (typeof drawEraBackgrounds === 'function') {
              drawEraBackgrounds();
            }
          }
          
          const rawData = embedded.events ? embedded.events : embedded;
          console.log('生データ取得:', Object.keys(rawData).length, '個の年');
          
          remoteData = normalizeAll(rawData);
          console.log('データ正規化完了:', Object.keys(remoteData).length, '個の年');
        } catch (e2) {
          console.error('埋め込みJSON読み込みエラー:', e2);
          console.error('エラーの詳細:', e2.message);
          console.error('スタックトレース:', e2.stack);
          
          // フォールバック: 直接オブジェクトを使用
          console.log('フォールバック: 直接オブジェクトを使用');
          const fallbackData = {
            "1952": [{"label":"テレビ放送開始"}],
            "1956": [{"label":"国産初コンピュータ"}],
            "1960": [{"label":"国鉄予約システム"},{"label":"ミステリーゾーン"}],
            "1963": [{"label":"鉄腕アトム"},{"label":"鉄人28号"}],
            "1966": [{"label":"ウルトラQ"},{"label":"サンダーバード"}],
            "1969": [{"label":"住友銀行キャッシュディスペンサ"},{"label":"アポロ11号・月着陸"}],
            "1971": [{"label":"仮面ライダー"}],
            "1973": [{"label":"『8時だョ！全員集合』視聴率50%"}],
            "1977": [{"label":"Apple IIなど初期マイコン"}],
            "1978": [{"label":"マイコン入り製品次々登場"}],
            "1979": [{"label":"機動戦士ガンダム"}],
            "1983": [{"label":"任天堂ファミコン"}],
            "1984": [{"label":"ドラゴンボール"}],
            "1986": [{"label":"PC-9801VM"},{"label":"ビデオレンタル・AVビデオ"}],
            "1995": [{"label":"新世紀エヴァンゲリオン"},{"label":"GHOST IN THE SHELL 攻殻機動隊"}],
            "1996": [{"label":"パソコン通信流行"},{"label":"女子高生にポケベルブーム"},{"label":"たまごっち"},{"label":"ホンダP2"}],
            "1999": [{"label":"iモード・写メール"},{"label":"MATRIX"}],
            "2001": [{"label":"ヤフー！BB開始"}],
            "2005": [{"label":"YouTube"}],
            "2006": [{"label":"『ぐぐる』が流行語大賞"}],
            "2007": [{"label":"電脳コイル"}],
            "2010": [{"label":"iPhoneブレーク"},{"label":"GAFAの影響力拡大"}],
            "2016": [{"label":"DJI Phantom 4／ドローン"}],
            "2018": [{"label":"Ready Player One"}],
            "2020": [{"label":"VR／メタバース注目"}],
            "2022": [{"label":"ChatGPT／生成AI"}],
            "2023": [{"label":"Web3"}]
          };
          remoteData = normalizeAll(fallbackData);
          console.log('フォールバックデータ正規化完了:', Object.keys(remoteData).length, '個の年');
        }
      }
      
      console.log('remoteDataの状態:', remoteData);
      
      if (remoteData !== null && remoteData !== undefined) {
        console.log('データ読み込み成功、イベント数:', Object.keys(remoteData).length);
        events = remoteData;
        saveEvents();
        renderEvents();
        // ジャンルが更新された可能性があるためフィルタ選択を全選択にリセット
        if (window.selectedGenres) { selectedGenres = new Set(GENRES); }
        if (typeof updateGenreFilterButtonText === 'function') { updateGenreFilterButtonText(); }
        // 時代区分背景を再描画
        if (typeof drawEraBackgrounds === 'function') {
          drawEraBackgrounds();
        }
        
        // 同期完了時刻を記録
        localStorage.setItem('lastSync', new Date().toISOString());
        lastSavedEventsData = JSON.stringify(events);
        updateSyncStatus();
        
        // 編集フラグをクリア
        clearEditFlags();
        
        const source = githubConfig.accessToken ? 'GitHub API' : 'GitHub raw file';
        showInfo('データ更新完了', `${source}から最新データを読み込みました。`);
      } else {
        console.error('remoteDataがnullまたはundefinedです');
        showError('読み込みエラー', 'データの読み込みに失敗しました。');
      }
    } catch (error) {
      showError('エラー', `データの更新中にエラーが発生しました: ${error.message}`);
    }
  }
  
  // グローバルに公開
  window.saveSettings = saveSettings;
  window.settingsLoadCsv = settingsLoadCsv;
  window.clearAllDataAndReload = clearAllDataAndReload;

  // 同期状態の表示（同期ボタン削除のため未使用）
  function updateSyncStatus() {}

  // 自動保存機能
  function autoSave() {
    try {
      const currentEvents = JSON.stringify(events);
      if (currentEvents !== lastSavedEventsData) {
        localStorage.setItem('autoSave', currentEvents);
        localStorage.setItem('lastEdit', new Date().toISOString());
        lastSavedEventsData = currentEvents;
        updateSyncStatus();
      }
    } catch (e) {
      console.error('自動保存エラー:', e);
    }
  }

  // 5秒ごとに自動保存
  setInterval(autoSave, 5000);

  // ページを閉じる時の確認
  function checkUnsavedChanges() {
    const lastSync = localStorage.getItem('lastSync');
    const lastEdit = localStorage.getItem('lastEdit');
    
    if (lastEdit && lastSync && lastEdit > lastSync) {
      return '保存されていない変更があります。\n\n本当にページを閉じますか？';
    }
    return null;
  }

  // beforeunloadイベントでページを閉じる前の確認
  window.addEventListener('beforeunload', function(e) {
    const message = checkUnsavedChanges();
    if (message) {
      e.preventDefault();
      e.returnValue = message;
      return message;
    }
  });

  // 初期化時に同期状態を更新
  updateSyncStatus();

  // ウィンドウリサイズ時に年齢表示の位置を再調整
  window.addEventListener('resize', updateAgeDisplayPosition);
  
  // ヘッダーの内容変更を監視して年齢表示の位置を再調整
  const header = document.querySelector('header');
  if (header) {
    const observer = new MutationObserver(() => {
      // 少し遅延させてから位置を調整（レイアウトが完了してから）
      setTimeout(updateAgeDisplayPosition, 10);
    });
    observer.observe(header, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['style', 'class']
    });
  }

  // イベントリスナー
  settingsBtn.addEventListener('click', function() {
    console.log('Settings button clicked');
    showSettings();
  });

  // 初期化時に設定を読み込み（既に上で実行済み）

  // ===== CSV/TSV ロード =====
  function detectDelim(sample){ const cntTab=(sample.match(/\t/g)||[]).length; const cntSemi=(sample.match(/;/g)||[]).length; const cntComma=(sample.match(/,/g)||[]).length; const arr=[["\t",cntTab],[";",cntSemi],[",",cntComma]].sort((a,b)=>b[1]-a[1]); return arr[0][1]>0 ? arr[0][0] : ';'; }
  fileInput.addEventListener('change', async (e)=>{ const f=e.target.files && e.target.files[0]; if(!f) return; const text = await f.text(); const {addedCount, errors} = importSeparatedText(text); if(errors.length){ const summary = `正常に追加: ${addedCount} 件`; showError('CSV/TSV読込エラー', [summary, ...errors]); } else if(addedCount>0){ saveEvents(); renderEvents(); showInfo('読み込み完了', `${addedCount} 件を追加しました。`); } else { showInfo('結果', '追加された項目はありませんでした。'); } if(addedCount>0){ saveEvents(); renderEvents(); } fileInput.value=''; });

  function importSeparatedText(text){
    const lines = text.replace(/^\uFEFF/, '').split(/\r?\n/);
    let firstNonEmpty = lines.find(l=>l.trim().length>0) || '';
    const delim = detectDelim(firstNonEmpty);
    let addedCount=0; const errors=[];
    const seen=buildLabelGenreSet();
    for(let i=0;i<lines.length;i++){
      const raw=lines[i].trim(); 
      // 改行のみの行と「#」で始まる行を無視
      if(!raw || raw.startsWith('#')) continue;
      const cols=raw.split(delim);
      if(i===0 && /年/.test(cols[0])) continue;
      if(cols.length<3){ errors.push(`${i+1}行目: 列数不足（開始年${delim}終了年${delim}ラベル${delim}ジャンル${delim}重要度${delim}URL${delim}注釈）`); continue; }
      const startYearStr=(cols[0]||'').trim();
      const endYearStr=(cols[1]||'').trim();
      const label=(cols[2]||'').trim();
      const genreStr=(cols[3]||'').trim();
      const impStr=(cols[4]||'').trim();
      const url=(cols[5]||'').trim();
      const note=(cols[6]||'').trim();
      
      // 開始年の検証
      if(startYearStr && !(startYearStr.match(/^\d{4}$/) && parseInt(startYearStr,10)>=YEAR_MIN && parseInt(startYearStr,10)<=YEAR_MAX)){
        errors.push(`${i+1}行目: 開始年が不正または範囲外（${startYearStr}）`); continue;
      }
      
      // 終了年の検証（「ongoing」も許可）
      if(endYearStr && endYearStr.toLowerCase() !== 'ongoing' && !(endYearStr.match(/^\d{4}$/) && parseInt(endYearStr,10)>=YEAR_MIN && parseInt(endYearStr,10)<=YEAR_MAX)){
        errors.push(`${i+1}行目: 終了年が不正または範囲外（${endYearStr}）`); continue;
      }
      
      // 開始年と終了年の関係性検証（「ongoing」の場合はスキップ）
      if(startYearStr && endYearStr && endYearStr.toLowerCase() !== 'ongoing' && parseInt(startYearStr,10) > parseInt(endYearStr,10)){
        errors.push(`${i+1}行目: 開始年が終了年より後になっています（${startYearStr} > ${endYearStr}）`); continue;
      }
      
      if(!label){ errors.push(`${i+1}行目: ラベルが空です`); continue; }
      const genres = genreStr ? genreStr.split('・').map(g => g.trim().toUpperCase()) : [];
      const genreKey = genres.length > 0 ? genres.map(g=>String(g).toUpperCase()).sort().join('・') : '';
      const key = `${label}|${genreKey}`;
      // 動的ジャンル: 不正チェックは行わず、そのまま受け入れ
      if(impStr){ const n=parseInt(impStr,10); if(!(n>=1 && n<=5)){ errors.push(`${i+1}行目: 不正な重要度（${impStr}）`); continue; } }
      
      // アイテムの年を決定（開始年があれば開始年、なければ終了年、どちらもなければエラー）
      let itemYear;
      if(startYearStr) {
        itemYear = parseInt(startYearStr,10);
      } else if(endYearStr && endYearStr.toLowerCase() !== 'ongoing') {
        itemYear = parseInt(endYearStr,10);
      } else if(endYearStr && endYearStr.toLowerCase() === 'ongoing') {
        // ongoingの場合は開始年が必要
        if(!startYearStr) {
          errors.push(`${i+1}行目: 終了年が「ongoing」の場合は開始年が必要です`); continue;
        }
        itemYear = parseInt(startYearStr,10);
      } else {
        errors.push(`${i+1}行目: 開始年または終了年のいずれかが必要です`); continue;
      }
      
      const item={ label }; 
      if(startYearStr) item.startYear=parseInt(startYearStr,10); 
      if(endYearStr) {
        if(endYearStr.toLowerCase() === 'ongoing') {
          item.endYear = 'ongoing';
        } else {
          item.endYear = parseInt(endYearStr,10);
        }
      } 
      if(genres.length > 0) item.genre=genres; 
      if(impStr) item.imp=parseInt(impStr,10); 
      if(url) item.url=url; 
      if(note) item.note=note;
      
      const deletedCol = (cols[7]||'').trim().toLowerCase();
      const isDeleted = deletedCol === 'true';

      if(!events[itemYear]) events[itemYear]=[]; 

      // 既存の同一キー（開始年・ラベル・ジャンル一致）を検索
      const sameKey = (it)=>{
        const gA = Array.isArray(it.genre) ? it.genre.slice().map(g=>String(g).toUpperCase()).sort().join('・') : (it.genre||'');
        return (it.label||'')===label && gA===genreKey && Number(it.startYear||itemYear)===Number(itemYear);
      };
      const arr = events[itemYear];
      const idx = arr.findIndex(sameKey);
      if(isDeleted){
        // (2) deleted=true の場合は該当項目を削除
        if(idx!==-1){ arr.splice(idx,1); }
        // リモートからも除去されるよう tombstone を記録
        try{ addDeletionRecord(itemYear, { startYear: itemYear, label, genre: (genres.length>0? genres : genreKey) }); }catch(_e){}
      } else {
        // (1) 同一キーがあれば上書き、なければ追加
        if(idx!==-1){ arr[idx] = item; } else { arr.push(item); }
        // seen は重複検出用。ここでは上書き対象も既存扱いにする
        seen.add(key);
        addedCount++;
      }
    }
    return {addedCount, errors};
  }

  // ===== 空年クリックで編集を開く =====
  function openEditorForEmptyYearAt(xCSS,yCSS){
    const rect=stage.getBoundingClientRect();
    const x=(xCSS-rect.left);
    const y=(yCSS-rect.top);
    if(x >= ORIGIN_X - HANDLE_LANE_W) return;
    const year = YEAR_MIN + Math.round((y-ORIGIN_Y)/PX_PER_YEAR);
    if(year<YEAR_MIN||year>YEAR_MAX) return;
    showEditModal(year, -1, { label: '', startYear: year, endYear: '' });
  }
  stage.addEventListener('click', (e)=>{ if(e.target && e.target.tagName && e.target.tagName.toLowerCase()==='text') return; openEditorForEmptyYearAt(e.clientX, e.clientY); });

  // ===== カスタム右クリックメニュー =====
  function hideCustomContextMenu(){
    if(customContextMenu){
      customContextMenu.style.display = 'none';
    }
  }
  function showCustomContextMenu(x,y){
    if(!customContextMenu) return;
    const z = pageZoom || 1;
    // body 全体を zoom しているので、メニュー位置も逆変換してカーソル直下に出す
    let left = x / z;
    let top  = y / z;
    customContextMenu.style.left = `${left}px`;
    customContextMenu.style.top  = `${top}px`;
    customContextMenu.style.display = 'block';
  }
  if(customContextMenu){
    customContextMenu.addEventListener('click',(e)=>{
      const btn = e.target.closest('button[data-action]');
      if(!btn) return;
      const action = btn.getAttribute('data-action');
      if(action === 'zoom-in'){
        pageZoom = Math.min(2.5, pageZoom + 0.1);
        applyPageZoom();
      }else if(action === 'zoom-out'){
        pageZoom = Math.max(0.5, pageZoom - 0.1);
        applyPageZoom();
      }else if(action === 'restart'){
        window.location.reload();
        return;
      }
      hideCustomContextMenu();
    });
  }
  // ブラウザ標準のコンテキストメニューを抑止し、カスタムメニューを表示
  window.addEventListener('contextmenu',(e)=>{
    e.preventDefault();
    showCustomContextMenu(e.clientX, e.clientY);
  });
  // 左クリックやスクロールなどでメニューを閉じる
  window.addEventListener('click',()=>{
    hideCustomContextMenu();
  });
  window.addEventListener('scroll',()=>{
    hideCustomContextMenu();
  });

  // ===== プローブ =====
  function makeProbe(color){
    const g=document.getElementById('probe-'+color);
    // 青プローブの初期位置: 生年1990（上の〇）、イベント年2010（下の〇）
    const state={eventYear:color==='blue'?2010:1999,birthYear:color==='blue'?1990:1964};
    const stroke=(color==='red'?'#ff3333':'#4da3ff');
    const eventLine=lineEl(ORIGIN_X,0,ORIGIN_X,0); eventLine.style.stroke=stroke; eventLine.style.strokeWidth=3; // 水平（交点まで）
    const vLine=lineEl(0,0,0,ORIGIN_Y);           vLine.style.stroke=stroke; vLine.style.strokeWidth=3; vLine.setAttribute('pointer-events','stroke'); vLine.style.touchAction='none';
    const diag=lineEl(0,0,0,0);                    diag.style.stroke=stroke;  diag.style.strokeWidth=3; // 左上斜め
    const eh=circleEl(HANDLE_X,0,8,'handle');      eh.setAttribute('stroke',stroke); eh.setAttribute('fill','#fff'); eh.style.touchAction='none';
    const bh=circleEl(HANDLE_X,0,8,'handle');      bh.setAttribute('stroke',stroke); bh.setAttribute('fill','#fff'); bh.style.touchAction='none';
    // 年齢表示を固定位置のHTML要素として作成
    const ageTextElement = document.createElement('div');
    ageTextElement.style.cssText = `
      position: fixed;
      top: 78px;
      left: 0;
      font-size: 18px;
      font-weight: 700;
      color: #000;
      pointer-events: none;
      z-index: 101;
      display: none;
    `;
    ageTextElement.id = `age-text-${color}`;
    document.body.appendChild(ageTextElement);
    
    const ageText=textEl('',0,0,'ageTickText'); // SVG要素は非表示にする
    const eventYearText=textEl('', ORIGIN_X+8, 0, 'ageTickText'); eventYearText.style.fontSize='14px'; eventYearText.style.fill=stroke; eventYearText.setAttribute('text-anchor','start');
    const birthYearText=textEl('', ORIGIN_X+8, 0, 'ageTickText'); birthYearText.style.fontSize='14px'; birthYearText.style.fill=stroke; birthYearText.setAttribute('text-anchor','start');

    g.append(eventLine,vLine,diag,eh,bh,ageText,eventYearText,birthYearText);

    function redraw(){
      const yE=yFromBirthYear(state.eventYear);
      const yB=yFromBirthYear(state.birthYear);
      const age=Math.max(0,Math.min(AGE_MAX,state.eventYear-state.birthYear));
      const ix=xFromAge(age);
      eventLine.setAttribute('y1',yE);eventLine.setAttribute('y2',yE); eventLine.setAttribute('x1',ORIGIN_X);eventLine.setAttribute('x2',ix);
      vLine.setAttribute('x1',ix);vLine.setAttribute('x2',ix);vLine.setAttribute('y1',yE);vLine.setAttribute('y2',ORIGIN_Y);
      const tMax=Math.max(0,Math.min((ix-ORIGIN_X)/PX_PER_AGE,(yE-ORIGIN_Y)/PX_PER_YEAR));
      diag.setAttribute('x1',ix);diag.setAttribute('y1',yE); diag.setAttribute('x2',ix-PX_PER_AGE*tMax);diag.setAttribute('y2',yE-PX_PER_YEAR*tMax);
      eh.setAttribute('cx',HANDLE_X);eh.setAttribute('cy',yE);
      bh.setAttribute('cx',HANDLE_X);bh.setAttribute('cy',yB);
      // HTML要素の年齢表示を更新（線の右側に表示）
      ageTextElement.textContent = `${age}歳`;
      const leftPx = ix + 10;
      ageTextElement.style.left = (window.innerWidth <= 768 && vp) ? `${leftPx - vp.scrollLeft}px` : `${leftPx}px`;
      ageTextElement.style.display = 'block';
      
      // 年齢表示の位置をヘッダーの高さに応じて調整
      updateAgeDisplayPosition();
      
      // SVG要素は非表示
      ageText.textContent = '';
      eventYearText.textContent = `${state.eventYear}年`;
      eventYearText.setAttribute('x', ORIGIN_X+8);
      eventYearText.setAttribute('y', yE-6);
      const yAtAxis = yE - age*PX_PER_YEAR; const by = Math.round((yAtAxis - ORIGIN_Y)/PX_PER_YEAR) + YEAR_MIN;
      birthYearText.textContent = `${by}年生`;
      birthYearText.style.fill = '#000'; // 生年表示を黒色に
      birthYearText.setAttribute('x', ORIGIN_X+8);
      birthYearText.setAttribute('y', yAtAxis-6);
      // 上下の〇が同じ年のときは下の〇(eh)をドラッグできるように、上の〇(bh)でクリックを受けない
      if (state.eventYear === state.birthYear) {
        bh.setAttribute('pointer-events', 'none');
      } else {
        bh.setAttribute('pointer-events', 'auto');
      }
    }

    function startDrag(){ document.body.classList.add('dragging'); }
    function endDrag(){ document.body.classList.remove('dragging'); }
    function dragByYear(el,prop){
      let dragging=false, startY=0, startVal=0;
      function onDragStart(clientY){
        dragging=true;
        startY=clientY;
        startVal=state[prop];
        startDrag();
        // ★ユーザー視点の「上の青い〇」は birthYear 側（bh）
        if (window.kioskMode && color==='blue' && el===bh && window.kioskState && !window.kioskState.eventYearMoved) {
          window.kioskState.eventYearMoved = true;
          window.kioskState.step = 3;
          window.kioskState.showLowerOverlay = true;
          updateKioskHint();
          updateKioskStepOverlay();
        }
        if (window.kioskMode && color==='blue' && el===eh && window.kioskState) {
          if (!window.kioskState.eventYearMoved) {
            window.kioskState.eventYearMoved = true;
            window.kioskState.step = 3;
            window.kioskState.showLowerOverlay = false;
            window.kioskState.step3StartedOperating = true;
            updateKioskHint();
            updateKioskStepOverlay();
          } else if (window.kioskState.showLowerOverlay) {
            window.kioskState.showLowerOverlay = false;
            window.kioskState.step3StartedOperating = true;
            updateKioskStepOverlay();
            updateKioskHint();
          }
        }
        if(color==='blue' && el===bh && window.updateProbeEventsPanel){
          const panel = document.getElementById('probeEventsPanel');
          if (panel){ panel.style.display = 'none'; panel.innerHTML = ''; }
        }
      }
      function onDragMove(clientY){
        if(!dragging) return;
        const dy=clientY-startY;
        const dYear=Math.round(dy/PX_PER_YEAR);
        state[prop]=Math.max(YEAR_MIN,Math.min(YEAR_MAX,startVal+dYear));
        redraw();
        if(color==='blue' && el===eh && window.updateProbeEventsPanel){ window.updateProbeEventsPanel(state.eventYear); }
      }
      function onDragEnd(){ if(dragging){ dragging=false; endDrag(); } }
      el.addEventListener('mousedown',e=>{ onDragStart(e.clientY); e.preventDefault(); e.stopPropagation(); });
      window.addEventListener('mousemove',e=>{ onDragMove(e.clientY); });
      window.addEventListener('mouseup',onDragEnd);
      el.addEventListener('touchstart',e=>{
        if(e.touches.length!==1) return;
        onDragStart(e.touches[0].clientY);
        e.preventDefault();
      },{passive:false});
      window.addEventListener('touchmove',e=>{
        if(!dragging || e.touches.length!==1) return;
        onDragMove(e.touches[0].clientY);
        e.preventDefault();
      },{passive:false});
      window.addEventListener('touchend',e=>{
        if(e.touches.length===0) onDragEnd();
      });
      window.addEventListener('touchcancel',e=>{
        if(e.touches.length===0) onDragEnd();
      });
    }
    dragByYear(eh,'eventYear'); dragByYear(bh,'birthYear'); dragByYear(vLine,'birthYear');

    state.redraw=redraw; redraw(); return state;
  }

  const probeBlue=makeProbe('blue');
  const probeRed=makeProbe('red');
  // 青プローブの初期位置（生年1990・イベント年2010）の上下両方の〇が見えるようにスクロール
  (function(){
    try{
      const yBirth = yFromBirthYear(probeBlue.birthYear);
      const yEvent = yFromBirthYear(probeBlue.eventYear);
      const vpH = vp.clientHeight || 0;
      const maxScroll = Math.max(0, vp.scrollHeight - vpH);
      if (vpH <= 0) return;
      const minY = Math.min(yBirth, yEvent);
      const maxY = Math.max(yBirth, yEvent);
      // 両方の〇がビューポート内に収まるように、必要なだけ上端を調整
      let top = minY - 40; // 少し上に余白
      if (maxY + 40 - top > vpH) {
        top = maxY + 40 - vpH;
      }
      vp.scrollTop = Math.max(0, Math.min(maxScroll, top));
    }catch(_e){}
  })();

  function scrollProbeBirthYearIntoView() {
    try {
      if (typeof probeBlue === 'undefined' || !vp) return;
      const yBirth = yFromBirthYear(probeBlue.birthYear);
      const vpH = vp.clientHeight || 0;
      const maxScroll = Math.max(0, vp.scrollHeight - vpH);
      if (vpH <= 0) return;
      const offsetFromTop = 2 * PX_PER_YEAR;
      let targetScroll = yBirth - offsetFromTop;
      targetScroll = Math.max(0, Math.min(maxScroll, targetScroll));
      vp.scrollTop = targetScroll;
    } catch (_e) {}
  }
  // 下の〇（イベント年）がヘッダより2年分下に来るようにスクロール（▼/▲用）
  function scrollProbeEventYearIntoView() {
    try {
      if (typeof probeBlue === 'undefined' || !vp) return;
      const yEvent = yFromBirthYear(probeBlue.eventYear);
      const vpH = vp.clientHeight || 0;
      const maxScroll = Math.max(0, vp.scrollHeight - vpH);
      if (vpH <= 0) return;
      const offsetFromTop = 2 * PX_PER_YEAR;
      let targetScroll = yEvent - offsetFromTop;
      targetScroll = Math.max(0, Math.min(maxScroll, targetScroll));
      vp.scrollTop = targetScroll;
    } catch (_e) {}
  }
  window.scrollProbeBirthYearIntoView = scrollProbeBirthYearIntoView;
  window.scrollProbeEventYearIntoView = scrollProbeEventYearIntoView;

  vp.addEventListener('scroll', ()=>{
    if (window.innerWidth <= 768) {
      probeBlue.redraw();
      probeRed.redraw();
    }
  });

  // ライン表示トグル（小丸ボタン）
  const blueGroup=document.getElementById('probe-blue');
  const redGroup =document.getElementById('probe-red');
  const toggleRedBtn =document.getElementById('toggleRed');
  function setToggle(btn, group, on){ group.style.display = on ? '' : 'none'; if(btn){ btn.setAttribute('aria-pressed', on ? 'true' : 'false'); btn.classList.toggle('off', !on); } }
  // 青プローブは常に表示（オン/オフボタンは廃止）
  if (toggleRedBtn) {
    toggleRedBtn.addEventListener('click',()=>{ const visible = redGroup.style.display !== 'none'; setToggle(toggleRedBtn, redGroup, !visible); });
    setToggle(toggleRedBtn, redGroup, false);
    toggleRedBtn.style.display = 'none';
  }

  // フィルタ変更
  function onFilterChange(){ filterImp=selImp.value.trim(); renderEvents(); }
  selImp.addEventListener('change', onFilterChange);
  
  // ジャンル選択モーダル関連の関数
  function showGenreFilterModal() {
    const genreLabels = GENRE_LABELS;
    
    let genreButtonsHtml = '';
    for (const genre of GENRES) {
      const isSelected = selectedGenres.has(genre);
      const label = (GENRE_LABELS && GENRE_LABELS[genre]) ? GENRE_LABELS[genre] : (genreLabels[genre] || genre);
      genreButtonsHtml += `
        <button class="genre-btn ${isSelected ? 'selected' : ''}" 
                data-genre="${genre}" 
                onclick="toggleGenre('${genre}')"
                style="padding: 8px 12px; border: 1px solid #e0e7ff; border-radius: 8px; cursor: pointer; background: ${isSelected ? '#6366f1' : '#f8fafc'}; color: ${isSelected ? 'white' : '#1e293b'};">
          ${label}
        </button>
      `;
    }
    
    const modalContent = `
      <div style="margin-bottom: 16px;">
        <button onclick="selectAllGenres()" style="margin-right: 8px; padding: 6px 12px; background: #6366f1; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight:600;">すべてを選択</button>
        <button onclick="deselectAllGenres()" style="padding: 6px 12px; background: #475569; color: white; border: none; border-radius: 8px; cursor: pointer;">すべてを解除</button>
      </div>
      <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-bottom: 16px;">
        ${genreButtonsHtml}
      </div>
      <div style="text-align: right;">
        <button onclick="applyGenreFilter()" style="padding: 8px 16px; background: #0d9488; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight:600;">適用</button>
      </div>
    `;
    
    openModal('ジャンル選択', modalContent, { footer: 'none' });
  }
  
  function toggleGenre(genre) {
    if (selectedGenres.has(genre)) {
      selectedGenres.delete(genre);
    } else {
      selectedGenres.add(genre);
    }
    // ボタンの表示を更新
    const btn = document.querySelector(`[data-genre="${genre}"]`);
    if (btn) {
      const isSelected = selectedGenres.has(genre);
      btn.classList.toggle('selected', isSelected);
      btn.style.background = isSelected ? '#6366f1' : '#f8fafc';
      btn.style.color = isSelected ? 'white' : '#1e293b';
    }
  }
  
  function selectAllGenres() {
    selectedGenres.clear();
    for (const genre of GENRES) {
      selectedGenres.add(genre);
    }
    // すべてのボタンを選択状態に更新
    document.querySelectorAll('.genre-btn').forEach(btn => {
      btn.classList.add('selected');
      btn.style.background = '#6366f1';
      btn.style.color = 'white';
    });
  }
  
  function deselectAllGenres() {
    selectedGenres.clear();
    // すべてのボタンを非選択状態に更新
    document.querySelectorAll('.genre-btn').forEach(btn => {
      btn.classList.remove('selected');
      btn.style.background = '#f8fafc';
      btn.style.color = '#1e293b';
    });
  }
  
  function applyGenreFilter() {
    closeModal();
    renderEvents();
    updateGenreFilterButtonText();
    if (window.kioskMode && typeof window.kioskOnGenresApplied === 'function') {
      window.kioskOnGenresApplied();
    }
  }
  
  // グローバルスコープで利用できるようにする
  window.toggleGenre = toggleGenre;
  window.selectAllGenres = selectAllGenres;
  window.deselectAllGenres = deselectAllGenres;
  window.applyGenreFilter = applyGenreFilter;
  window.addEraItem = addEraItem;
  window.saveEraSettings = saveEraSettings;
  
  // ジャンルごとの登録件数を計算する関数
  function getGenreCounts() {
    const counts = {};
    const genreLabels = GENRE_LABELS;
    
    // 各ジャンルの件数を初期化
    for (const code of GENRES) counts[code] = 0;
    
    // 実際のデータから件数を計算（配列ジャンル対応）
    for (const items of Object.values(events)) {
      for (const item of (items || [])) {
        const g = item.genre;
        if (Array.isArray(g)) {
          for (const codeRaw of g) {
            const code = String(codeRaw || 'UNC').toUpperCase();
            if (!(code in counts)) counts[code] = 0; // 未知ジャンルも計上
            counts[code]++;
          }
        } else {
          const code = String(g || 'UNC').toUpperCase();
          if (!(code in counts)) counts[code] = 0;
          counts[code]++;
        }
      }
    }
    
    return counts;
  }
  
  // 総登録件数を取得する関数
  function getTotalItemCount() {
    let total = 0;
    for (const [year, items] of Object.entries(events)) {
      total += items.length;
    }
    return total;
  }
  
  // ジャンル一覧を件数付きで生成する関数
  function generateGenreListWithCounts() {
    const counts = getGenreCounts();
    const genreLabels = GENRE_LABELS;
    
    return GENRES.map(genre => {
      const count = counts[genre] || 0;
      const label = (GENRE_LABELS && GENRE_LABELS[genre]) ? GENRE_LABELS[genre] : (genreLabels[genre] || genre);
      return `<li><strong>${genre}:</strong> ${label}（${count}）</li>`;
    }).join('');
  }
  
  function updateGenreFilterButtonText() {
    if (selectedGenres.size === 0) {
      genreFilterBtn.textContent = 'ジャンル選択';
    } else if (selectedGenres.size === GENRES.length) {
      genreFilterBtn.textContent = 'すべてのジャンル';
    } else {
      genreFilterBtn.textContent = `${selectedGenres.size}個のジャンル`;
    }
  }
  
  // ジャンルフィルタボタンのイベントリスナー
  genreFilterBtn.addEventListener('click', showGenreFilterModal);
  
  // 時代区分ボタンのイベントリスナー
  const eraBtn = document.getElementById('eraBtn');
  eraBtn.addEventListener('click', showEraSettingsModal);

  // ===== キオスク体験モード（イベント会場向けアンケート） =====
  window.kioskMode = true;
  const kioskState = {
    step: 0,          // 0: スタート前, 1: ジャンル選択, 2: 生年セット, 3: イベント選択中, 4: 診断表示
    step3StartedOperating: false, // スマホでステップ3の説明を消しコンパクト表示にするフラグ
    gender: '',       // スタート時アンケートの性別
    nickname: '',     // スタート時アンケートのニックネーム（保存しない）
    selections: [],   // { year, label, genre, imp }
    eventYearMoved: false,
    showLowerOverlay: false
  };
  window.kioskState = kioskState;
  let kioskModalPhase = null; // 'diag' | 'overall' | 'usage' | null

  function ensureKioskHint() {
    let box = document.getElementById('kioskHint');
    if (box) return box;
    box = document.createElement('div');
    box.id = 'kioskHint';
    box.style.display = 'none';
    box.innerHTML = `
      <strong></strong>
      <div class="body"></div>
      <div class="count"></div>
      <button type="button" id="kioskNextBtn"></button>
      <button type="button" id="kioskFinishBtn" style="display:none;"></button>
      <span class="kiosk-year-controls" id="kioskYearControls" style="display:none;">
        <button type="button" id="kioskYearUpBtn" aria-label="年を1つ進める">▼年＋</button>
        <button type="button" id="kioskYearDownBtn" aria-label="年を1つ戻す">▲年－</button>
      </span>
    `;
    document.body.appendChild(box);
    return box;
  }

  function ensureKioskStepOverlay() {
    let el = document.getElementById('kioskStepOverlay');
    if (el) return el;
    el = document.createElement('div');
    el.id = 'kioskStepOverlay';
    document.body.appendChild(el);
    return el;
  }

  function updateKioskStepOverlay() {
    const el = ensureKioskStepOverlay();
    if (!window.kioskMode) {
      el.style.display = 'none';
      return;
    }
    const isMobile = window.matchMedia('(max-width: 768px)').matches;
    const step3Compact = kioskState.step === 3 && isMobile && kioskState.step3StartedOperating;
    if (step3Compact) {
      el.style.display = 'none';
      return;
    }
    let text = '';
    if (kioskState.step === 1) {
      text = 'ジャンルを選んでください。１～数個のジャンルを選んでください。';
    } else if (kioskState.step === 2 && !kioskState.eventYearMoved) {
      text = '上の〇（青い斜め線の左上付近にある）を生年にあわせてください。スクロールして遡ることもできます';
    } else if (kioskState.step === 3 && kioskState.showLowerOverlay) {
      text = '下の〇（青い横線の左端付近にある）を動かしてください。青い縦線の上にその年の年齢が表示されます。０歳以前へや動かせます。出てきた一覧でチェックしてください';
    }
    if (text) {
      el.textContent = text;
      el.style.display = 'block';
    } else {
      el.style.display = 'none';
    }
  }

  function updateKioskHint() {
    const box = ensureKioskHint();
    const titleEl = box.querySelector('strong');
    const bodyEl = box.querySelector('.body');
    const countEl = box.querySelector('.count');
    const nextBtn = box.querySelector('#kioskNextBtn');
    const finishBtn = box.querySelector('#kioskFinishBtn');
    const yearControls = box.querySelector('#kioskYearControls');

    titleEl.style.display = '';
    bodyEl.style.display = '';
    countEl.style.display = '';
    if (yearControls) yearControls.style.display = 'none';
    box.classList.remove('kiosk-hint-step3-compact');
    document.body.classList.remove('kiosk-step3-compact-hint');
    box.style.display = 'block';
    finishBtn.style.display = 'none';

    const count = kioskState.selections.length;
    countEl.textContent = `選んだコンテンツ数: ${count} / 10 以上で診断できます`;

    if (kioskState.step === 1) {
      titleEl.textContent = 'ステップ1：ジャンルを選びましょう';
      bodyEl.textContent = '関心のあるジャンルをいくつか選んでください（マンガ、アニメ、ゲームなど）。「適用」を押すと次へ進みます。表示したいジャンルは画面上の「ジャンル選択」メニューからいつでも変更できます。';
      nextBtn.style.display = 'none';
    } else if (kioskState.step === 2) {
      titleEl.textContent = 'ステップ2：生まれた年をセット';
      bodyEl.textContent = '青いプローブの上の丸を上下にドラッグして、左の年表にある自分の生まれ年の高さに合わせてください。';
      nextBtn.style.display = 'none';
      finishBtn.style.display = 'none';
    } else if (kioskState.step === 3) {
      const isMobile = window.matchMedia('(max-width: 768px)').matches;
      const step3Compact = isMobile && kioskState.step3StartedOperating;
      if (step3Compact) {
        document.body.classList.add('kiosk-step3-compact-hint');
        titleEl.style.display = 'none';
        bodyEl.style.display = 'none';
        box.classList.add('kiosk-hint-step3-compact');
        countEl.textContent = count + '/10';
        countEl.style.display = 'block';
        nextBtn.style.display = 'none';
        finishBtn.style.display = 'inline-block';
        finishBtn.textContent = '診断';
        finishBtn.disabled = count < 10;
        if (yearControls) yearControls.style.display = 'flex';
        if (typeof window.scrollProbeEventYearIntoView === 'function') {
          setTimeout(function() { window.scrollProbeEventYearIntoView(); }, 100);
        }
      } else {
        titleEl.style.display = '';
        bodyEl.style.display = '';
        box.classList.remove('kiosk-hint-step3-compact');
        titleEl.textContent = 'ステップ3：チェックボックで選択';
        const cfr = getCfrPrompts();
        const desc = cfr.eventChecklistDescription || DEFAULT_CFR_PROMPTS.eventChecklistDescription;
        bodyEl.textContent = desc + ' 10個以上チェックすると「診断」ボタンが押せるようになります。';
        countEl.textContent = '選んだコンテンツ数: ' + count + ' / 10 以上で診断できます';
        nextBtn.style.display = 'none';
        finishBtn.style.display = 'inline-block';
        finishBtn.textContent = '診断';
        finishBtn.disabled = count < 10;
      }
    } else if (kioskState.step === 4) {
      titleEl.textContent = 'ありがとうございました';
      bodyEl.textContent = 'お疲れさまでした。m(_ _)m ';
      nextBtn.style.display = 'none';
      finishBtn.style.display = 'none';
    } else {
      box.style.display = 'none';
    }
    updateKioskStepOverlay();
  }

  function kioskOnGenresApplied() {
    if (!window.kioskMode) return;
    if (kioskState.step < 1) return;
    kioskState.step = 2;
    kioskState.eventYearMoved = false;
    kioskState.showLowerOverlay = false;
    kioskState.step3StartedOperating = false;
    updateKioskHint();
  }
  window.kioskOnGenresApplied = kioskOnGenresApplied;

  const KIOSK_NICKNAME_MAX = 16;
  const KIOSK_NICKNAME_DEFAULT = 'Guest';
  function normalizeKioskNickname(raw) {
    const chars = Array.from(String(raw || '').trim());
    const clipped = chars.slice(0, KIOSK_NICKNAME_MAX).join('');
    return clipped || KIOSK_NICKNAME_DEFAULT;
  }
  function escapeHtmlText(s) {
    return String(s || '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }
  function toKatakana(s) {
    return String(s).replace(/[\u3041-\u3096]/g, ch => String.fromCharCode(ch.charCodeAt(0) + 0x60));
  }
  function setupKioskNicknamePad(overlay) {
    const input = overlay.querySelector('#kioskNicknameInput');
    const modeWrap = overlay.querySelector('#kioskPadModes');
    const subWrap = overlay.querySelector('#kioskPadSubModes');
    const grid = overlay.querySelector('#kioskPadGrid');
    if (!input || !modeWrap || !subWrap || !grid) return;
    // モード切替行をキーボードの下へ移動（左:モード / 右:編集キー）
    if (grid.parentNode) {
      grid.parentNode.insertBefore(modeWrap, grid.nextSibling);
      grid.parentNode.insertBefore(subWrap, modeWrap.nextSibling);
    }

    const KANA_MOD_KEY = '__KANA_MOD_KEY__';
    const kanaRows = [
      ['わ','ら','や','ま','は','な','た','さ','か','あ'],
      ['を','り','','み','ひ','に','ち','し','き','い'],
      ['ん','る','ゆ','む','ふ','ぬ','つ','す','く','う'],
      ['ー','れ','','め','へ','ね','て','せ','け','え'],
      [KANA_MOD_KEY,'ろ','よ','も','ほ','の','と','そ','こ','お']
    ];
    const upperRows = [
      ['1','2','3','4','5','6','7','8','9','0'],
      ['Q','W','E','R','T','Y','U','I','O','P'],
      ['A','S','D','F','G','H','J','K','L',''],
      ['@','Z','X','C','V','B','N','M','-','_']
    ];
    const lowerRows = [
      ['1','2','3','4','5','6','7','8','9','0'],
      ['q','w','e','r','t','y','u','i','o','p'],
      ['a','s','d','f','g','h','j','k','l',''],
      ['@','z','x','c','v','b','n','m','-','_']
    ];

    const st = {
      mode: 'lower' // kana | kata | upper | lower
    };

    function pushChar(ch) {
      const chars = Array.from(input.value || '');
      if (chars.length >= KIOSK_NICKNAME_MAX) return;
      chars.push(ch);
      input.value = chars.join('');
    }
    function backspaceOne() {
      const chars = Array.from(input.value || '');
      chars.pop();
      input.value = chars.join('');
    }
    function clearAll() {
      input.value = '';
    }
    const kanaTransformCycles = [
      ['か','が'],['き','ぎ'],['く','ぐ'],['け','げ'],['こ','ご'],
      ['さ','ざ'],['し','じ'],['す','ず'],['せ','ぜ'],['そ','ぞ'],
      ['た','だ'],['ち','ぢ'],['つ','づ'],['て','で'],['と','ど'],
      ['は','ば','ぱ'],['ひ','び','ぴ'],['ふ','ぶ','ぷ'],['へ','べ','ぺ'],['ほ','ぼ','ぽ'],
      ['う','ゔ'],
      ['あ','ぁ'],['い','ぃ'],['う','ぅ'],['え','ぇ'],['お','ぉ'],
      ['や','ゃ'],['ゆ','ゅ'],['よ','ょ'],['つ','っ'],['わ','ゎ'],
      ['カ','ガ'],['キ','ギ'],['ク','グ'],['ケ','ゲ'],['コ','ゴ'],
      ['サ','ザ'],['シ','ジ'],['ス','ズ'],['セ','ゼ'],['ソ','ゾ'],
      ['タ','ダ'],['チ','ヂ'],['ツ','ヅ'],['テ','デ'],['ト','ド'],
      ['ハ','バ','パ'],['ヒ','ビ','ピ'],['フ','ブ','プ'],['ヘ','ベ','ペ'],['ホ','ボ','ポ'],
      ['ウ','ヴ'],
      ['ア','ァ'],['イ','ィ'],['ウ','ゥ'],['エ','ェ'],['オ','ォ'],
      ['ヤ','ャ'],['ユ','ュ'],['ヨ','ョ'],['ツ','ッ'],['ワ','ヮ']
    ];
    function cycleLastKanaChar() {
      const chars = Array.from(input.value || '');
      if (!chars.length) return;
      const last = chars[chars.length - 1];
      for (const cycle of kanaTransformCycles) {
        const idx = cycle.indexOf(last);
        if (idx !== -1) {
          chars[chars.length - 1] = cycle[(idx + 1) % cycle.length];
          input.value = chars.join('');
          return;
        }
      }
    }

    function mkBtn(label, onClick, cssText) {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.textContent = label;
      btn.style.cssText = cssText || 'padding:6px 10px; border-radius:8px; border:1px solid #ccc; background:#fff; color:#222; cursor:pointer; font-size:14px; font-weight:500;';
      btn.addEventListener('click', onClick);
      return btn;
    }

    function render() {
      modeWrap.innerHTML = '';
      subWrap.innerHTML = '';
      grid.innerHTML = '';

      const modeBtnCss = 'padding:6px 10px; border-radius:8px; border:1px solid #ccc; cursor:pointer; font-size:14px; font-weight:600;';
      const activeCss = 'background:#6366f1; color:#fff; border-color:#6366f1;';
      const normalCss = 'background:#f8fafc; color:#1e293b;';

      // ラッパー: スマホは2段（かな〜abc / 空白〜←）、PCは1行（左: かな〜abc、右: 空白〜←）
      const bottomWrap = document.createElement('div');
      bottomWrap.className = 'kiosk-pad-modes-inner';
      bottomWrap.style.cssText = 'display:flex; flex-direction:column; gap:8px; width:100%;';
      // 1行目: かな・カナ・ABC・abc
      const modeRow = document.createElement('div');
      modeRow.className = 'kiosk-pad-mode-row';
      modeRow.style.cssText = 'display:flex; gap:6px; flex-wrap:wrap; justify-content:flex-start; width:100%; margin-bottom:8px;';
      const kanaBtn = mkBtn('かな', () => { st.mode = 'kana'; render(); }, modeBtnCss + (st.mode === 'kana' ? activeCss : normalCss));
      const kataBtn = mkBtn('カナ', () => { st.mode = 'kata'; render(); }, modeBtnCss + (st.mode === 'kata' ? activeCss : normalCss));
      const abcBtn  = mkBtn('ABC', () => { st.mode = 'upper'; render(); }, modeBtnCss + (st.mode === 'upper' ? activeCss : normalCss));
      const abcLowerBtn = mkBtn('abc', () => { st.mode = 'lower'; render(); }, modeBtnCss + (st.mode === 'lower' ? activeCss : normalCss));
      modeRow.appendChild(kanaBtn);
      modeRow.appendChild(kataBtn);
      modeRow.appendChild(abcBtn);
      modeRow.appendChild(abcLowerBtn);

      // 2行目: 空白・Clear・←（スマホでは下段、PCでは右側に表示）
      const actionRow = document.createElement('div');
      actionRow.className = 'kiosk-pad-action-row';
      actionRow.style.cssText = 'display:flex; justify-content:space-between; align-items:center; gap:8px; width:100%;';
      subWrap.style.display = 'none';

      const keyCss = 'padding:0; height:50px; border-radius:8px; border:1px solid #9f9f9f; background:#e6e6e6; color:#222; cursor:pointer; font-size:20px; line-height:1.2; font-weight:500;';
      const makeCharBtn = (ch) => mkBtn(ch, () => pushChar(ch), keyCss);
      const makeKanaModBtn = () => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.style.cssText = 'padding:0; height:50px; border-radius:8px; border:1px solid #f4b46b; background:#fff3e0; color:#e65100; cursor:pointer; font-size:16px; line-height:1.1; font-weight:700;';
        btn.textContent = '゛゜/小';
        btn.addEventListener('click', cycleLastKanaChar);
        return btn;
      };
      const addRow = (arr, transformFn, halfShift) => {
        arr.forEach(ch => {
          if (!ch) {
            const spacer = document.createElement('div');
            spacer.setAttribute('aria-hidden', 'true');
            grid.appendChild(spacer);
            return;
          }
          if (ch === KANA_MOD_KEY) {
            grid.appendChild(makeKanaModBtn());
            return;
          }
          const btn = makeCharBtn(transformFn ? transformFn(ch) : ch);
          if (halfShift) {
            // ASDF 行を半キー分だけ右にずらす
            btn.style.transform = 'translateX(calc(50% + 3px))';
          }
          grid.appendChild(btn);
        });
      };

      if (st.mode === 'kana') {
        kanaRows.forEach(r => addRow(r));
      } else if (st.mode === 'kata') {
        kanaRows.forEach(r => addRow(r, toKatakana));
      } else if (st.mode === 'upper') {
        upperRows.forEach((r, idx) => addRow(r, null, idx === 2));
      } else {
        lowerRows.forEach((r, idx) => addRow(r, null, idx === 2));
      }

      const actionBaseCss = 'padding:8px 14px; border-radius:10px; cursor:pointer; line-height:1.2; font-weight:600;';
      const spaceBtn = mkBtn('空白', () => pushChar(' '), actionBaseCss + 'border:1px solid #8a8a8a; background:#e0e0e0; color:#111; font-size:16px; font-weight:500; min-width:88px;');
      const clearBtn = mkBtn('Clear', clearAll, actionBaseCss + 'border:1px solid #c45b5b; background:#fff; color:#7a1b1b; font-size:20px; font-weight:500; min-width:88px;');
      const backBtn = mkBtn('←', backspaceOne, actionBaseCss + 'border:1px solid #c45b5b; background:#fff; color:#7a1b1b; font-size:24px; font-weight:800; min-width:76px;');
      actionRow.appendChild(spaceBtn);
      actionRow.appendChild(clearBtn);
      actionRow.appendChild(backBtn);
      bottomWrap.appendChild(modeRow);
      bottomWrap.appendChild(actionRow);
      modeWrap.appendChild(bottomWrap);
    }

    input.readOnly = true;
    input.inputMode = 'none';
    input.maxLength = KIOSK_NICKNAME_MAX;
    input.placeholder = KIOSK_NICKNAME_DEFAULT;
    render();
  }

  function openKioskStartOverlay() {
    const overlay = document.createElement('div');
    overlay.id = 'kioskStartOverlay';
    const wizard = {
      step: 1,
      gender: '',
      nickname: normalizeKioskNickname(kioskState.nickname || '')
    };

    const renderStep = () => {
      if (wizard.step === 1) {
        const cfr = getCfrPrompts();
        const topTitle = cfr.topTitle || DEFAULT_CFR_PROMPTS.topTitle;
        const topDesc  = cfr.topDescription || DEFAULT_CFR_PROMPTS.topDescription;
        overlay.innerHTML = `
          <div class="inner">
            <h2 style="font-size:24px; line-height:1.4; margin-bottom:10px;">${escapeHtmlText(topTitle)}</h2>
            <p style="font-size:18px; line-height:1.7;">${escapeHtmlText(topDesc)}</p>
            <p style="margin-top:24px; font-size:12px; color:#888; text-align:left;">(c) 2026 Satoshi Endo / The timeline data for Xnative/Timeline is published under CC BY-SA 4.0.</p>
            <div class="actions">
              <button type="button" id="kioskStep1NextBtn">次へ</button>
            </div>
          </div>
        `;
        const nextBtn = overlay.querySelector('#kioskStep1NextBtn');
        if (nextBtn) {
          nextBtn.addEventListener('click', () => {
            wizard.step = 2;
            renderStep();
          });
        }
        return;
      }

      if (wizard.step === 2) {
        overlay.innerHTML = `
          <div class="inner">
            <div style="margin:12px 0; padding:10px 12px; border-radius:8px; background:#f8fafc; border:1px solid #e0e7ff; font-size:13px;">
              <div style="margin-bottom:6px; font-size:18px;">あなたの属性とニックネームを教えてください</div>
              <div style="display:flex; flex-wrap:wrap; gap:8px 16px; align-items:center; font-size:18px;">
                <div>
                  <span>性別:</span>
                  <label style="margin-left:4px;"><input type="radio" name="kioskGender" value="男"> 男</label>
                  <label style="margin-left:4px;"><input type="radio" name="kioskGender" value="女"> 女</label>
                  <label style="margin-left:4px;"><input type="radio" name="kioskGender" value="答えない"> 答えない</label>
                </div>
              </div>
              <div style="margin-top:8px;">
                <div style="margin-bottom:6px; font-size:18px;">ニックネーム（最大16文字）:</div>
                <input type="text" id="kioskNicknameInput" placeholder="Guest" style="width:100%; max-width:520px; font-size:18px; padding:8px 10px; border-radius:8px; border:1px solid #ccc;" aria-label="ニックネーム（クリック入力）">
                <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;" id="kioskPadModes"></div>
                <div style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap;" id="kioskPadSubModes"></div>
                <div id="kioskPadGrid" style="margin-top:8px; display:grid; grid-template-columns:repeat(10, minmax(0, 1fr)); gap:6px;"></div>
              </div>
            </div>
            <div class="actions">
              <button type="button" id="kioskStep2NextBtn">次へ</button>
            </div>
          </div>
        `;
        setupKioskNicknamePad(overlay);
        const nickInput = overlay.querySelector('#kioskNicknameInput');
        if (nickInput) {
          if (wizard.nickname && wizard.nickname !== KIOSK_NICKNAME_DEFAULT) {
            nickInput.value = wizard.nickname;
          } else {
            nickInput.value = '';
          }
        }
        if (wizard.gender) {
          const radio = overlay.querySelector(`input[name="kioskGender"][value="${wizard.gender}"]`);
          if (radio) radio.checked = true;
        }
        const nextBtn = overlay.querySelector('#kioskStep2NextBtn');
        if (nextBtn) {
          nextBtn.addEventListener('click', () => {
            const genderInput = [...overlay.querySelectorAll('input[name="kioskGender"]')].find(r => r.checked);
            const gender = genderInput ? genderInput.value : '';
            if (!gender) {
              alert('性別を選んでください。');
              return;
            }
            wizard.gender = gender;
            wizard.nickname = normalizeKioskNickname(nickInput ? nickInput.value : '');
            wizard.step = 3;
            renderStep();
          });
        }
        return;
      }

      overlay.innerHTML = `
        <div class="inner">
          <div style="margin-top:6px; font-size:18px; color:#666;">
            ※アンケート結果のみ集計に使われていただきます。
          </div>
          <div style="margin-top:6px; font-size:18px; color:#666;">
            ※途中で出てくる地球マーク<span style="pointer-events:none;">🌐</span>にポインタを合わせるとWikipediaなどのページが表示されます。
          </div>
          <div class="actions">
            <button type="button" id="kioskStartBtn">診断スタート</button>
          </div>
        </div>
      `;
      const startBtn = overlay.querySelector('#kioskStartBtn');
      if (startBtn) {
        startBtn.addEventListener('click', () => {
          kioskState.gender = wizard.gender || '';
          kioskState.nickname = normalizeKioskNickname(wizard.nickname || '');
          kioskState.step = 1;
          document.body.classList.add('kiosk-mode');
          overlay.remove();
          ensureKioskHint();
          updateKioskHint();
          // すぐにジャンル選択モーダルを開く
          showGenreFilterModal();
        });
      }
    };

    document.body.appendChild(overlay);
    renderStep();
  }

  function openKioskChecklist(year) {
    if (!window.kioskMode || kioskState.step !== 3) return;
    const list = (events[year] || []).filter(passesFilter);
    if (!list.length) {
      openModalText('イベントがありません', `${year}年には現在、選択できるイベントが登録されていません。別の年をお試しください。`);
      return;
    }
    const itemsHtml = list.map((it, idx) => {
      const key = `${year}__${it.label}`;
      const already = kioskState.selections.some(s => s.year === year && s.label === it.label);
      const checkedAttr = already ? 'checked' : '';
      return `
        <label style="display:block; margin:4px 0; cursor:pointer; font-size:20px;">
          <input type="checkbox" name="kioskItem" value="${key}" data-idx="${idx}" ${checkedAttr} style="margin-right:6px;">
          <strong>${it.label}</strong>
          ${it.genre ? `<span style="color:#666; font-size:17px;">[${Array.isArray(it.genre)?it.genre.join('・'):it.genre}]</span>` : ''}
        </label>
      `;
    }).join('');

    const html = `
      <p><strong>${year}年</strong> のイベントの中から選んでください。</p>
      <div style="max-height:320px; overflow-y:auto; margin-top:8px;">
        ${itemsHtml}
      </div>
      <p style="margin-top:8px; font-size:17px; color:#666;">※すでに選んだものにはチェックが入っています。</p>
      <div style="text-align:right; margin-top:12px;">
        <button type="button" id="kioskChecklistOk" style="padding:6px 12px; border-radius:8px; border:none; background:#0d9488; color:#fff; cursor:pointer; font-weight:600;">決定</button>
      </div>
    `;
    openModal('イベント選択', html);
    const okBtn = document.getElementById('kioskChecklistOk');
    okBtn.addEventListener('click', () => {
      const checks = [...document.querySelectorAll('input[name="kioskItem"]:checked')];
      if (!checks.length) {
        openModalText('選択が必要です', '少なくとも1つは選んでください。');
        return;
      }
      if (checks.length > 3) {
        openModalText('選びすぎです', '1～3個の範囲で選んでください。');
        return;
      }
      checks.forEach(chk => {
        const idx = parseInt(chk.dataset.idx, 10);
        const it = list[idx];
        if (!it) return;
        const exists = kioskState.selections.some(s => s.year === year && s.label === it.label);
        if (!exists) {
          kioskState.selections.push({
            year,
            label: it.label,
            genre: it.genre,
            imp: it.imp
          });
        }
      });
      kioskState.step3StartedOperating = true;
      closeModal();
      updateKioskHint();
    });
  }

  function buildKioskReportAndAggregate() {
    const selections = kioskState.selections.slice();
    const total = selections.length;
    // decade 集計
    const decadeCount = {};
    selections.forEach(s => {
      const d = Math.floor(s.year / 10) * 10;
      decadeCount[d] = (decadeCount[d] || 0) + 1;
    });
    // ジャンル集計
    const genreCount = {};
    selections.forEach(s => {
      const g = s.genre;
      if (Array.isArray(g)) {
        g.forEach(code => {
          const c = String(code || 'UNC').toUpperCase();
          genreCount[c] = (genreCount[c] || 0) + 1;
        });
      } else if (g) {
        const c = String(g || 'UNC').toUpperCase();
        genreCount[c] = (genreCount[c] || 0) + 1;
      }
    });
    const sortedDecades = Object.keys(decadeCount).map(Number).sort((a,b)=>a-b);
    const sortedGenres = Object.keys(genreCount).sort((a,b)=>(genreCount[b]-genreCount[a]));

    let report = '';
    report += `あなたは全部で${total}個のコンテンツを選びました。その中で特に多かったのは、`;
    if (sortedDecades.length) {
      const topDecade = sortedDecades.reduce((a,b)=> decadeCount[a] >= decadeCount[b] ? a : b);
      report += `${topDecade}年代（${decadeCount[topDecade]}件）です。`;
    } else {
      report += '特定の年代に偏りは見られませんでした。';
    }
    report += '\n\n';
    if (sortedGenres.length) {
      const lines = sortedGenres.slice(0,3).map(code => {
        const label = (GENRE_LABELS && GENRE_LABELS[code]) ? GENRE_LABELS[code] : code;
        return `${label}（${genreCount[code]}件）`;
      });
      report += `ジャンル別では、${lines.join('、')} などへの関心が強く表れています。`;
    } else {
      report += 'ジャンルの偏りはあまり見られませんでした。';
    }
    report += '\n\n';
    report += 'これらから推測すると、あなたは自分の成長期に触れた作品やサービスを通じて、時代の変化を前向きに楽しむタイプであり、テクノロジーや物語世界に対する想像力が豊かな人格が形成されていると考えられます。（この診断文は現在ダミーであり、将来は生成AIから約1000文字のレポートを取得する予定です。）';

    // みんなの集計（ローカルストレージに蓄積）
    const key = 'xnative_kiosk_aggregate_v1';
    let agg;
    try {
      agg = JSON.parse(localStorage.getItem(key) || 'null') || { count:0, decade:{}, };
    } catch(e) {
      agg = { count:0, decade:{} };
    }
    agg.count += 1;
    Object.keys(decadeCount).forEach(d => {
      agg.decade[d] = (agg.decade[d] || 0) + decadeCount[d];
    });
    try {
      localStorage.setItem(key, JSON.stringify(agg));
    } catch(e) {}

    // グラフHTML（簡易棒グラフ）
    const maxGlobal = Math.max(1, ...Object.values(agg.decade));
    const decadeBars = Object.keys(agg.decade).sort((a,b)=>a-b).map(d => {
      const gVal = agg.decade[d];
      const uVal = decadeCount[d] || 0;
      const width = 140 * (gVal / maxGlobal);
      return `
        <div style="margin:4px 0; font-size:12px;">
          <div style="display:flex; justify-content:space-between;">
            <span>${d}年代</span>
            <span>全体:${gVal} / あなた:${uVal}</span>
          </div>
          <div style="position:relative; height:10px; background:#e0e7ff; border-radius:5px; overflow:hidden;">
            <div style="position:absolute; left:0; top:0; bottom:0; width:${width}px; background:#a5b4fc;"></div>
            ${uVal ? `<div style="position:absolute; left:0; top:0; bottom:0; width:${140*(uVal/Math.max(gVal,1))}px; background:#6366f1; opacity:0.95;"></div>` : ''}
          </div>
        </div>
      `;
    }).join('');

    const aggregateHtml = `
      <p>これまでにこの端末で回答した人数: <strong>${agg.count}人</strong></p>
      <p>年代ごとの選択傾向（全体とあなたの比較）:</p>
      <div style="max-width:300px;">${decadeBars || '<p>今回が最初の回答です。</p>'}</div>
    `;

    return { report, aggregateHtml };
  }

  function buildGeminiPrompt(headOverride) {
    const birthYear = (typeof probeBlue !== 'undefined' && probeBlue.birthYear != null) ? probeBlue.birthYear : '';
    const gender = kioskState.gender || '';
    const nickname = normalizeKioskNickname(kioskState.nickname || '');
    const lines = kioskState.selections.map(s => `${s.year}年: ${s.label}`).join('\n');
    const cfr = getCfrPrompts();
    const head = headOverride || cfr.geminiPromptHead || DEFAULT_CFR_PROMPTS.geminiPromptHead;
    return head + `ニックネーム: ${nickname}\n性別: ${gender}\n生年: ${birthYear}年\n\n選択したコンテンツ（年: イベント名）:\n${lines}`;
  }
  const GEMINI_MODEL = 'gemini-2.5-flash-lite';
  // ローカル開発時（localhost）にブラウザから直接Gemini APIを呼ぶヘルパー
  function getTemperature() {
    const cfr = getCfrPrompts();
    const t = cfr.temperature ?? DEFAULT_CFR_PROMPTS.temperature ?? 0.9;
    const n = Number(t);
    return (Number.isNaN(n) || n < 0 || n > 2) ? 0.9 : n;
  }

  async function callGeminiDirect(apiKey, prompt) {
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${encodeURIComponent(apiKey)}`;
    const temp = getTemperature();
    try {
      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{ parts: [{ text: prompt }] }],
          generationConfig: { maxOutputTokens: 2048, temperature: temp }
        })
      });
      let data = null;
      try {
        const raw = await res.text();
        if (raw) data = JSON.parse(raw);
      } catch (_) {}
      if (!res.ok) {
        let errMsg = `HTTP ${res.status}`;
        if (data && data.error && data.error.message) errMsg += ': ' + data.error.message;
        else if (data && data.error) errMsg += ': ' + JSON.stringify(data.error);
        return { ok: false, error: errMsg };
      }
      const text = data && data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts[0] ? data.candidates[0].content.parts[0].text : null;
      if (text && text.trim()) return { ok: true, text: text.trim() };
      return { ok: false, error: 'APIは応答しましたが、診断テキストが含まれていませんでした。' };
    } catch (e) {
      const msg = (e && e.message) ? e.message : String(e);
      return { ok: false, error: '通信エラー: ' + msg };
    }
  }

  // Cloudflare / Netlify などのサーバ側で環境変数を使って呼び出す場合のバックエンド経由呼び出し
  async function callGeminiViaBackend(prompt) {
    const payload = { prompt, model: GEMINI_MODEL, temperature: getTemperature() };
    const endpoints = [
      '/api/gemini-diagnosis',                 // Cloudflare Pages Functions 等で /api/ 以下に配置した場合
      '/.netlify/functions/gemini-diagnosis'   // Netlify Functions
    ];

    let lastError = 'バックエンドエンドポイントに接続できませんでした。';
    for (const ep of endpoints) {
      try {
        const res = await fetch(ep, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!res.ok) {
          // 404 の場合は「このエンドポイントは存在しない」とみなして次を試す
          if (res.status === 404) {
            lastError = `HTTP 404 (${ep})`;
            continue;
          }
          const txt = await res.text().catch(() => '');
          return { ok: false, error: `HTTP ${res.status}: ${txt}` };
        }
        const data = await res.json().catch(() => null);
        if (data && typeof data.ok === 'boolean') {
          return data;
        }
        // 想定外フォーマット
        return { ok: false, error: 'バックエンドの応答形式が不正です。' };
      } catch (e) {
        lastError = (e && e.message) ? e.message : String(e);
      }
    }
    return { ok: false, error: lastError };
  }

  // OpenAI をサーバ側経由で呼び出す
  async function callOpenAiViaBackend(prompt) {
    try {
      const res = await fetch('/api/openai-diagnosis', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ prompt, temperature: getTemperature() })
      });
      const data = await res.json().catch(() => null);
      if (!res.ok || !data) {
        const msg = (data && data.error) ? data.error : `HTTP ${res.status}`;
        return { ok: false, error: String(msg) };
      }
      return data;
    } catch (e) {
      const msg = (e && e.message) ? e.message : String(e);
      return { ok: false, error: '通信エラー: ' + msg };
    }
  }

  // 実際に診断テキストを取得するメイン関数（headOverride を指定すると別プロンプトで呼び出し）
  async function fetchGeminiDiagnosis(headOverride) {
    const prompt = buildGeminiPrompt(headOverride);
    const cfr = getCfrPrompts();
    const provider = ((cfr.aiProvider || DEFAULT_CFR_PROMPTS.aiProvider || 'gemini') + '').toLowerCase();

    // OpenAI が指定されている場合は常にサーバ経由で OpenAI を呼び出す
    if (provider === 'openai') {
      return await callOpenAiViaBackend(prompt);
    }

    const apiKey = (typeof window !== 'undefined' && window.GEMINI_API_KEY) ? String(window.GEMINI_API_KEY).trim() : '';
    const isLocalhost =
      typeof location !== 'undefined' &&
      (location.hostname === 'localhost' || location.hostname === '127.0.0.1');

    // 1) ローカル開発: localhost かつ window.GEMINI_API_KEY がある場合は従来どおりブラウザから直接呼ぶ
    if (isLocalhost && apiKey) {
      return await callGeminiDirect(apiKey, prompt);
    }

    // 2) 本番など: Cloudflare / Netlify のサーバレス関数経由で呼ぶ
    const backendResult = await callGeminiViaBackend(prompt);
    if (backendResult.ok) return backendResult;

    // 3) バックエンドが未設定だが、どうしてもフロントから直接呼びたい場合のフォールバック（キーは露出します）
    if (!isLocalhost && apiKey) {
      console.warn('バックエンドが見つからないため、フロントエンドから直接Gemini APIを呼び出します（APIキーはクライアントに露出します）。');
      return await callGeminiDirect(apiKey, prompt);
    }

    // 4) どちらも使えない場合
    return {
      ok: false,
      error: backendResult.error || 'Gemini APIの呼び出し方法が構成されていません。（環境変数付きバックエンドか、ローカル用config.jsを設定してください）'
    };
  }

  const KIOSK_SESSIONS_KEY = 'xnative_kiosk_sessions_v1';
  function saveKioskSessionToStorage() {
    try {
      const birthYear = (typeof probeBlue !== 'undefined' && probeBlue.birthYear != null) ? probeBlue.birthYear : null;
      const raw = localStorage.getItem(KIOSK_SESSIONS_KEY) || '[]';
      const list = JSON.parse(raw);
      list.push({
        timestamp: new Date().toISOString(),
        gender: kioskState.gender || '',
        birthYear: birthYear,
        selections: kioskState.selections.map(s => {
          const arr = events[s.year] || [];
          const item = arr.find(it => it.label === s.label) || {};
          const genre = s.genre != null ? s.genre : item.genre;
          const url = item.url || '';
          const urlEn = item.url_e || item.url_en || item.URL_en || item.URL_e || item.urlEn || '';
          const note = item.note || '';
          return { year: s.year, label: s.label, genre: genre, url: url, urlEn: urlEn, note: note };
        })
      });
      localStorage.setItem(KIOSK_SESSIONS_KEY, JSON.stringify(list));
    } catch (e) {}
  }

  // 診断結果をサーバー側に送信（Railway/Fly.io は /api/、Netlify は .netlify/functions/）。1つ成功したら終了
  function submitDiagnosticResultToBackend(record) {
    const endpoints = [
      '/api/diagnostic-result',                 // Railway / Fly.io (Express)
      '/.netlify/functions/diagnostic-result'  // Netlify Functions
    ];
    const body = JSON.stringify(record);
    (async function tryEndpoints() {
      for (const ep of endpoints) {
        try {
          const res = await fetch(ep, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: body
          });
          if (res.ok) {
            console.log('診断結果をサーバーに送信しました:', ep);
            return;
          }
          if (res.status === 404) continue;
        } catch (_) {}
      }
    })();
  }

  async function showKioskResult() {
    saveKioskSessionToStorage();
    // 集約用：サーバー側に診断結果を1件送信（バックエンドが有効な場合のみ保存される）
    const birthYear = (typeof probeBlue !== 'undefined' && probeBlue.birthYear != null) ? probeBlue.birthYear : null;
    const record = {
      timestamp: new Date().toISOString(),
      nickname: normalizeKioskNickname(kioskState.nickname || ''),
      gender: kioskState.gender || '',
      birthYear: birthYear,
      owner: githubConfig.owner || '',
      repo: githubConfig.repo || '',
      filePath: githubConfig.filePath || '',
      selections: kioskState.selections.map(s => ({ year: s.year, label: s.label, genre: s.genre != null ? s.genre : '' })),
      // 診断実行時点でジャンル選択モーダルで選ばれていたジャンルコードの一覧
      selectedGenres: Array.from(selectedGenres || [])
    };
    submitDiagnosticResultToBackend(record);
    const { report: dummyReport, aggregateHtml } = buildKioskReportAndAggregate();
    let report = dummyReport;
    const geminiResult = await fetchGeminiDiagnosis();
    if (geminiResult.ok) {
      report = geminiResult.text;
    } else {
      report = '【診断の取得に失敗しました】\n\n' + (geminiResult.error || '不明なエラー') + '\n\n※上記の理由でAI診断を取得できなかったため、以下はダミーの診断文です。\n\n' + dummyReport;
    }
    kioskState.step = 4;
    updateKioskHint();
    // 診断結果表示時はイベントチェックリストを消す
    if (probeEventsPanel) {
      probeEventsPanel.style.display = 'none';
      probeEventsPanel.innerHTML = '';
      lastProbeEventYear = null;
    }
    const nickname = normalizeKioskNickname(kioskState.nickname || '');
    const cfr = getCfrPrompts();
    const topTitle = cfr.topTitle || DEFAULT_CFR_PROMPTS.topTitle;
    const html = `
      <h4>あなたの${escapeHtmlText(topTitle)}の結果です</h4>
      <p style="margin:8px 0 10px; font-size:14px;">ニックネーム: <strong>${escapeHtmlText(nickname)}</strong></p>
      <p style="white-space:pre-wrap; font-size:13px; line-height:1.7;">${report.replace(/</g,'&lt;')}</p>
      <div style="margin-top:16px; border-top:1px solid #eee; padding-top:12px;">
        <h4>簡易グラフィック（みんなとの比較）</h4>
        ${aggregateHtml}
      </div>
      <div style="margin-top:16px; display:flex; flex-wrap:wrap; gap:16px;">
        <div>
          <button type="button" id="kioskQrPersonalBtn" style="padding:6px 12px; border-radius:8px; border:1px solid #e0e7ff; background:#f8fafc; color:#1e293b; cursor:pointer;">個人レポートのQRを表示</button>
        </div>
        <div>
          <button type="button" id="kioskQrGroupBtn" style="padding:6px 12px; border-radius:8px; border:1px solid #e0e7ff; background:#f8fafc; color:#1e293b; cursor:pointer;">みんなとの比較QRを表示</button>
          <div id="kioskQrGroup" class="kiosk-qr-box" style="display:none;">QRコード（ダミー）</div>
        </div>
      </div>
      <p style="margin-top:16px; font-size:12px; color:#666;">QRを読み取ると、チェックしたイベント一覧と診断結果のテキストが表示されます。</p>
    `;
    kioskModalPhase = 'diag';
    openModal('診断結果', html, { footer: 'next' });
    const pBtn = document.getElementById('kioskQrPersonalBtn');
    const gBtn = document.getElementById('kioskQrGroupBtn');
    const gBox = document.getElementById('kioskQrGroup');
    if (pBtn) {
      pBtn.addEventListener('click', () => {
        const selectedListText = (kioskState.selections || [])
          .slice()
          .sort((a, b) => a.year === b.year ? a.label.localeCompare(b.label) : a.year - b.year)
          .map(s => `${s.year}年: ${s.label}`)
          .join('\n');
        const fullReportText =
          '【ニックネーム】\n' + nickname +
          '\n\n【チェックした項目】\n' + (selectedListText || '（なし）') +
          '\n\n【診断結果】\n' + report;
        const isTooBigError = (err) => {
          const s = String((err && err.message) ? err.message : (err || '')).toLowerCase();
          return s.includes('too big') || s.includes('too long') || s.includes('code length overflow') || s.includes('input too long');
        };
        const trimToBytes = (text, maxBytes) => {
          const bytes = new TextEncoder().encode(text);
          if (bytes.length <= maxBytes) return text;
          let i = maxBytes;
          while (i > 0 && (bytes[i - 1] & 0xC0) === 0x80) i--;
          return new TextDecoder('utf-8').decode(bytes.slice(0, i)) + '\n［文字数制限のため末尾を省略］';
        };
        const candidateTexts = (() => {
          const limits = [Infinity, 2800, 2600, 2400, 2200, 2000, 1800, 1600, 1400, 1200, 1000, 800];
          const arr = limits.map(l => (l === Infinity ? fullReportText : trimToBytes(fullReportText, l)));
          return arr.filter((t, i) => i === 0 || t !== arr[i - 1]);
        })();
        let overlay = document.getElementById('kioskQrPersonalOverlay');
        if (overlay) overlay.remove();
        overlay = document.createElement('div');
        overlay.id = 'kioskQrPersonalOverlay';
        overlay.innerHTML = '<div class="kiosk-qr-img" style="color:#fff;font-size:18px;">QR生成中…</div><button type="button" class="kiosk-qr-close">閉じる</button>';
        overlay.querySelector('.kiosk-qr-close').addEventListener('click', () => overlay.remove());
        document.body.appendChild(overlay);
        const showQrOverlay = (dataUrl) => {
          const wrap = overlay.querySelector('.kiosk-qr-img');
          wrap.innerHTML = '';
          const img = document.createElement('img');
          img.src = dataUrl;
          img.alt = '個人レポートQR';
          wrap.appendChild(img);
        };
        const showError = (msg) => {
          const wrap = overlay.querySelector('.kiosk-qr-img');
          wrap.style.color = '#f88';
          wrap.textContent = msg || 'QRの生成に失敗しました';
        };
        const runGenerate = () => {
          const qrSize = Math.min(520, Math.min(window.innerWidth, window.innerHeight) - 80);
          try {
            const Q = window.QRCode || window.qrcode || (typeof QRCode !== 'undefined' ? QRCode : null);
            if (!Q) {
              showError('QRライブラリが読み込めません');
              return;
            }
            const canvas = document.createElement('canvas');
            const opts = { width: qrSize, margin: 2, errorCorrectionLevel: 'L' };
            const attempt = (idx) => {
              if (idx >= candidateTexts.length) {
                showError('QRに入りきらないため生成できませんでした');
                return;
              }
              const text = candidateTexts[idx];
              const onTooBigOrFail = (err) => {
                if (isTooBigError(err)) return attempt(idx + 1);
                showError('生成エラー');
                console.error(err);
              };
              if (typeof Q.toCanvas === 'function') {
                Q.toCanvas(canvas, text, opts, (err) => {
                  if (err) return onTooBigOrFail(err);
                  try {
                    showQrOverlay(canvas.toDataURL('image/png'));
                  } catch (e) { showError('画像の作成に失敗'); console.error(e); }
                });
                return;
              }
              if (typeof Q.toDataURL === 'function') {
                const cb = (err, dataUrl) => {
                  if (err) return onTooBigOrFail(err);
                  showQrOverlay(dataUrl);
                };
                try {
                  const p = Q.toDataURL(text, opts);
                  if (p && typeof p.then === 'function') p.then(showQrOverlay).catch(onTooBigOrFail);
                  else Q.toDataURL(text, opts, cb);
                } catch (e1) {
                  try { Q.toDataURL(text, { width: qrSize }, cb); } catch (e2) { onTooBigOrFail(e2); }
                }
                return;
              }
              showError('QR APIが見つかりません');
            };
            attempt(0);
            return;
          } catch (e) {
            showError('QRの生成に失敗しました');
            console.error(e);
          }
        };
        if (window.QRCode || window.qrcode) {
          runGenerate();
          return;
        }
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/qrcode@1.5.4/build/qrcode.min.js';
        script.crossOrigin = 'anonymous';
        script.onload = runGenerate;
        script.onerror = () => {
          const s2 = document.createElement('script');
          s2.src = 'https://unpkg.com/qrcode@1.5.4/build/qrcode.min.js';
          s2.crossOrigin = 'anonymous';
          s2.onload = runGenerate;
          s2.onerror = () => showError('QRライブラリの読み込みに失敗しました');
          document.head.appendChild(s2);
        };
        document.head.appendChild(script);
      });
    }
    if (gBtn && gBox) {
      gBtn.addEventListener('click', () => {
        gBox.style.display = gBox.style.display === 'none' ? 'flex' : 'none';
      });
    }
  }

  function showKioskSelectionsSummary() {
    if (!window.kioskMode) return;
    const list = kioskState.selections.slice();
    if (!list.length) {
      openModalText('選択がありません', 'まだコンテンツが選択されていません。');
      return;
    }
    const itemsHtml = list
      .sort((a,b)=>a.year===b.year ? a.label.localeCompare(b.label) : a.year-b.year)
      .map(s => {
        const year = s.year;
        const items = (events[year] || []);
        const it = items.find(i => i.label === s.label) || {};
        const jpUrl = it.url || '';
        const enUrl = it.url_e || it.url_en || it.URL_en || it.URL_e || it.urlEn || '';
        const hasJpUrl = !!jpUrl;
        const hasEnUrl = !!enUrl;
        const labelEn = it.label_en || '';
        return `
          <li>
            <span style="font-size:18px; display:inline-flex; align-items:center; gap:8px; flex-wrap:wrap;">
              <span style="min-width:3em; color:#666; flex-shrink:0;">${year}年</span>
              <strong style="flex-shrink:0;">${s.label}</strong>
              ${hasJpUrl ? `<span class="probe-web-icon" data-web-url="${jpUrl}" title="関連ページを表示" style="cursor:pointer; flex-shrink:0;">🌐</span>` : ''}
              <span style="display:inline; font-size:18px;">${labelEn ? `<span style="color:#444;">${labelEn}</span>` : ''}${(labelEn && hasEnUrl) ? ' ' : ''}${hasEnUrl ? `<span class="probe-web-icon" data-web-url="${enUrl}" title="English page" style="cursor:pointer;">🌐</span>` : ''}</span>
            </span>
          </li>
        `;
      })
      .join('');
    const html = `
      <p style="font-size:20px;">これまでにチェックした項目の一覧です。OKなら「終了して診断」を選んでください。</p>
      <ul style="max-height:300px; overflow-y:auto; padding-left:18px; font-size:18px; margin-top:8px;">
        ${itemsHtml}
      </ul>
      <div style="margin-top:16px; display:flex; justify-content:flex-end; gap:8px;">
        <button type="button" id="kioskBackToCheckBtn" style="padding:6px 12px; border-radius:8px; border:1px solid #e0e7ff; background:#f8fafc; color:#1e293b; cursor:pointer;">チェックに戻る</button>
        <button type="button" id="kioskGoResultBtn" style="padding:6px 12px; border-radius:8px; border:none; background:#0d9488; color:#fff; cursor:pointer; font-weight:600;">終了して診断する</button>
      </div>
    `;
    kioskModalPhase = null;
    openModal('選択内容の確認', html, { footer: 'none' });
    const backBtn = document.getElementById('kioskBackToCheckBtn');
    const goBtn = document.getElementById('kioskGoResultBtn');
    if (backBtn) {
      backBtn.addEventListener('click', () => {
        closeModal();
      });
    }
    if (goBtn) {
      goBtn.addEventListener('click', () => {
        closeModal();
        const loadingHtml = '<div class="kiosk-diagnosing"><div class="spinner"></div><p>AIで診断を生成しています。<br>しばらくお待ちください。</p></div>';
        openModal('診断中', loadingHtml, { footer: 'none' });
        showKioskResult();
      });
    }
  }

  const formatSessionRow = (ses, idx, formatDate) => {
    const nickText = (ses.nickname != null && ses.nickname !== '') ? (String(ses.nickname).replace(/</g, '&lt;')) : '—';
    const genderText = (ses.gender != null && ses.gender !== '') ? ses.gender : '—';
    const birthYearText = (ses.birthYear != null && ses.birthYear !== '') ? (ses.birthYear + '年生') : '—';
    const lines = (ses.selections || []).map(s => `${s.year}年: ${(s.label || '').replace(/</g, '&lt;')}`).join('<br>');
    return `<div style="margin-bottom:12px; padding-bottom:10px; border-bottom:1px solid #eee;"><strong>${idx + 1}. ${formatDate(ses.timestamp)}</strong> ニックネーム: ${nickText} / 性別: ${genderText} / 生年: ${birthYearText}（選択${(ses.selections || []).length}件）<br><span style="color:#444;">${lines || '（なし）'}</span></div>`;
  };

  async function showKioskOverallResult() {
    if (!window.kioskMode) return;
    const cfr = getCfrPrompts();
    const overallTitle = cfr.overallTitle || DEFAULT_CFR_PROMPTS.overallTitle;
    const overallDesc  = cfr.overallDescription || DEFAULT_CFR_PROMPTS.overallDescription;
    let secondPromptHtml = '';

    // プロンプト2が設定されている場合は、診断結果画面の「次へ」でここに来たタイミングで追加のGemini呼び出しを行う
    const secondHead = cfr.secondPromptHead || DEFAULT_CFR_PROMPTS.secondPromptHead || '';
    if (secondHead && secondHead.trim()) {
      try {
        const secondResult = await fetchGeminiDiagnosis(secondHead);
        if (secondResult && secondResult.ok && secondResult.text) {
          secondPromptHtml = `
      <div style="margin-top:16px; padding-top:12px; border-top:1px dashed #ddd;">
        <h4 style="margin:0 0 8px; font-size:16px;">追加のおすすめコンテンツ</h4>
        <p style="white-space:pre-wrap; font-size:13px; line-height:1.7;">${secondResult.text.replace(/</g,'&lt;')}</p>
      </div>`;
        } else if (secondResult && !secondResult.ok && secondResult.error) {
          secondPromptHtml = `
      <p style="margin-top:12px; font-size:12px; color:#b91c1c;">※ 追加診断の取得に失敗しました: ${secondResult.error.replace(/</g,'&lt;')}</p>`;
        }
      } catch (e) {
        // 追加診断が失敗しても全体画面の表示自体は続行
        console.warn('追加Gemini診断の取得に失敗しました:', e);
      }
    }
    let sessions = [];
    try {
      sessions = JSON.parse(localStorage.getItem(KIOSK_SESSIONS_KEY) || '[]');
    } catch (e) {}
    const formatDate = (iso) => {
      try {
        const d = new Date(iso);
        return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0') + ' ' + String(d.getHours()).padStart(2, '0') + ':' + String(d.getMinutes()).padStart(2, '0');
      } catch (_) { return iso; }
    };
    let serverHtml = '';
    try {
      const res = await fetch('/api/diagnostic-results');
      if (res.ok) {
        const data = await res.json().catch(() => ({}));
        const serverList = (data && data.results && Array.isArray(data.results)) ? data.results : [];
        serverHtml = serverList.length === 0
          ? '<p style="font-size:14px; color:#666;">サーバーにはまだ蓄積されたデータはありません。</p>'
          : `<p style="margin:0 0 8px; font-size:16px;">サーバーに蓄積されたチェック内容（全端末・${serverList.length}件）：</p><div style="max-height:320px; overflow-y:auto; border:1px solid #ddd; border-radius:8px; padding:10px 12px; background:#f0f8ff; font-size:14px; line-height:1.6;">${serverList.map((ses, idx) => formatSessionRow(ses, idx, formatDate)).join('')}</div>`;
      }
    } catch (_) {}
    const localHtml = sessions.length === 0
      ? '<p style="font-size:14px; color:#666;">この端末（localStorage）にはまだ蓄積されたデータはありません。</p>'
      : `<p style="margin:0 0 8px; font-size:16px;">この端末に保存されたチェック内容（${sessions.length}件のセッション）：</p><div style="max-height:320px; overflow-y:auto; border:1px solid #ddd; border-radius:8px; padding:10px 12px; background:#fafafa; font-size:14px; line-height:1.6;">${sessions.map((ses, idx) => formatSessionRow(ses, idx, formatDate)).join('')}</div>`;
    const accumulatedHtml = serverHtml ? `<div style="margin-bottom:16px;">${serverHtml}</div><h4 style="margin:12px 0 8px; font-size:16px;">この端末（localStorage）</h4>${localHtml}` : `<h4 style="margin:0 0 8px; font-size:16px;">蓄積されたチェック内容</h4>${localHtml}`;
    const html = `
      <p style="font-size:18px;">${overallDesc.replace(/</g,'&lt;')}</p>
      ${secondPromptHtml}
      <div style="margin-top:16px; border-top:1px solid #eee; padding-top:12px;">
        <h4 style="margin:0 0 8px; font-size:16px;">蓄積されたチェック内容</h4>
        ${accumulatedHtml}
      </div>
      <div style="margin-top:16px; border-top:1px solid #eee; padding-top:12px;">
        <p style="margin:0 0 6px; font-size:18px;">Xnative Timeline に興味のある方はこちら：</p>
        <button type="button" id="kioskXnativeBtn" style="padding:6px 12px; border-radius:8px; border:1px solid #ccc; background:#f5f5f5; cursor:pointer; font-size:18px;">
          Xnative Timeline の年表一覧を表示
        </button>
        <div id="kioskXnativeFrameWrap" style="margin-top:10px; width:100%; height:260px; display:none;">
          <iframe src="https://nativemap2.pages.dev/" title="Xnative Timeline 一覧"
                  style="width:100%; height:100%; border:1px solid #ccc; border-radius:8px; background:#fff;"></iframe>
        </div>
      </div>
    `;
    kioskModalPhase = 'overall';
    openModal(overallTitle, html, { footer: 'next' });
    const btn = document.getElementById('kioskXnativeBtn');
    const wrap = document.getElementById('kioskXnativeFrameWrap');
    if (btn && wrap) {
      btn.addEventListener('click', () => {
        wrap.style.display = wrap.style.display === 'none' ? 'block' : 'none';
      });
    }
  }

  let kioskUsageMouseHandler = null;
  function showKioskUsageScreen() {
    if (!window.kioskMode) return;
    const cfr = getCfrPrompts();
    const desc = cfr.usageDescription || DEFAULT_CFR_PROMPTS.usageDescription;
    const html = `
      <div style="height:260px; display:flex; flex-direction:column; align-items:center; justify-content:center; font-size:14px; color:#666; gap:16px;">
        <div>${(desc || '').replace(/</g,'&lt;').replace(/\\n/g,'<br>')}</div>
        <button type="button" id="kioskUsageStartBtn" style="padding:8px 16px; border-radius:10px; border:1px solid #ccc; background:#007bff; color:#fff; cursor:pointer;">
          スタート
        </button>
      </div>
    `;
    kioskModalPhase = 'usage';
    const usageTitle = cfr.usageTitle || DEFAULT_CFR_PROMPTS.usageTitle;
    openModal(usageTitle, html, { footer: 'none' });
    const startBtn = document.getElementById('kioskUsageStartBtn');
    if (startBtn) {
      startBtn.addEventListener('click', () => {
        closeModal(); // closeModal 経由で resetKioskToStart が呼ばれて先頭画面へ
      });
    }
  }

  function resetKioskToStart() {
    // 状態リセット
    kioskState.step = 0;
    kioskState.selections = [];
    kioskState.nickname = '';
    kioskState.eventYearMoved = false;
    kioskState.showLowerOverlay = false;
    kioskState.step3StartedOperating = false;
    document.body.classList.remove('kiosk-step3-compact-hint');
    // チェック状態クリア
    if (typeof probeCheckedKeys !== 'undefined' && probeCheckedKeys.clear) {
      probeCheckedKeys.clear();
    }
    if (typeof lastProbeEventYear !== 'undefined') {
      lastProbeEventYear = null;
    }
    if (probeEventsPanel) {
      probeEventsPanel.style.display = 'none';
      probeEventsPanel.innerHTML = '';
    }
    const hint = document.getElementById('kioskHint');
    if (hint) hint.style.display = 'none';
    const stepEl = document.getElementById('kioskStepOverlay');
    if (stepEl) stepEl.style.display = 'none';
    // ジャンル選択をリセット
    selectedGenres.clear();
    updateGenreFilterButtonText && updateGenreFilterButtonText();
    renderEvents();
    // 最初のオーバーレイを再表示（必要なら CFR プロンプト設定を読み込んでから）
    try {
      ensureCfrPromptsLoaded().then(() => {
        openKioskStartOverlay();
      });
    } catch (_) {
      openKioskStartOverlay();
    }
  }

  (async function setupKioskFlow(){
    if (!window.kioskMode) return;
    // CFR プロンプト設定を先に読み込んでからスタートオーバーレイを表示
    try {
      await ensureCfrPromptsLoaded();
    } catch (_) {}
    openKioskStartOverlay();
    const hintBox = ensureKioskHint();
    const nextBtn = hintBox.querySelector('#kioskNextBtn');
    const finishBtn = hintBox.querySelector('#kioskFinishBtn');
    const yearUpBtn = hintBox.querySelector('#kioskYearUpBtn');
    const yearDownBtn = hintBox.querySelector('#kioskYearDownBtn');
    // 「次へ」はステップ遷移には使わない（常に非表示）
    nextBtn.addEventListener('click', () => {});
    finishBtn.addEventListener('click', () => {
      if (kioskState.step === 3 && kioskState.selections.length >= 10) {
        showKioskSelectionsSummary();
      }
    });
    if (yearUpBtn) {
      yearUpBtn.addEventListener('click', () => {
        if (typeof probeBlue === 'undefined') return;
        probeBlue.eventYear = Math.min(YEAR_MAX, probeBlue.eventYear + 1);
        probeBlue.redraw();
        if (typeof window.scrollProbeEventYearIntoView === 'function') window.scrollProbeEventYearIntoView();
        if (typeof window.updateProbeEventsPanel === 'function') window.updateProbeEventsPanel(probeBlue.eventYear);
      });
    }
    if (yearDownBtn) {
      yearDownBtn.addEventListener('click', () => {
        if (typeof probeBlue === 'undefined') return;
        probeBlue.eventYear = Math.max(YEAR_MIN, probeBlue.eventYear - 1);
        probeBlue.redraw();
        if (typeof window.scrollProbeEventYearIntoView === 'function') window.scrollProbeEventYearIntoView();
        if (typeof window.updateProbeEventsPanel === 'function') window.updateProbeEventsPanel(probeBlue.eventYear);
      });
    }
    // 右側チェックリストに一本化したため、マウスアップ時のチェックリストモーダルは使用しない
  })();

  // ヘルプ（画面展開に沿った構成）
  document.getElementById('helpBtn').addEventListener('click', ()=>{
    const helpHtml = `
      <h2>概要</h2>
      <p>自分が生まれて何歳の頃に何に出会ったかをチェックしていくことで、AIによる分析を行うシステムです。年表データごとにAIの分析方法が異なっています。何年のときに自分は何歳だったか分かるようになっていて、Wikipediaなどの関連ページも容易に見ることができます。当時の状況を思い浮かべたり確認しながらチェックしていき、楽しみながら自分の人生を俯瞰しながらチェックしていってください。自分の生まれる前の事柄もあるので年を示すプローブの〇は、生年よりも前に動かすこともできます。項目がバランスよくチェックされたか確認したら「診断」へ進んでください。生年と性別、チェック項目を集計、他の人たちのチェック内容との比較や分析も行います（現時点では未実装）。それにより、たとえば日本のコンテンツ消費者（広い意味でのオタク）を64分類するといったことを目指しています。</p>
      <h2>1. 画面の流れ（診断モード）</h2>
      <ol>
        <li><strong>開始画面</strong> → タイトル・説明を読み「次へ」。</li>
        <li><strong>属性入力</strong> → 性別とニックネームを入力し「次へ」。</li>
        <li><strong>診断スタート</strong> → 「診断スタート」で本編へ。</li>
        <li><strong>ステップ1：ジャンル</strong> → 関心のあるジャンルを選び「適用」。</li>
        <li><strong>ステップ2：生年</strong> → 青い<strong>上の〇</strong>をドラッグして生年に合わせる。</li>
        <li><strong>ステップ3：イベント選択</strong> → <strong>下の〇</strong>で年を変え、一覧から10個以上チェック。スマホでは「▼年＋」「▲年－」で年を進め・戻せる。</li>
        <li><strong>診断</strong> → 「診断」を押すとAI診断が実行され、結果が表示される。</li>
      </ol>
      <h2>2. プローブの操作（使いかたの例：任天堂ファミコン）</h2>
      <p>任天堂のファミコン発売時の年齢を知りたいとします。</p>
      <ol>
        <li><strong>イベント年（下の〇）：</strong> ドラッグレーンの<strong>水色の丸</strong>（横線の左端付近）を上下にドラッグし、左の年表で<strong>「83 任天堂ファミコン」</strong>と同じ高さに揃える。縦軸に <em>「1983年」</em> と表示される。</li>
        <li><strong>生年（上の〇）：</strong> 水色の斜め線の左端付近の<strong>水色の丸</strong>を上下にドラッグし、生年（例：<em>1965年生</em>）に合わせる。上部に <em>「18歳」</em> と表示される。</li>
      </ol>
      <h2>3. 基本操作</h2>
      <ul>
        <li><strong>スクロール：</strong> ホイール／トラックパッド／矢印キー、スマホではタップなどの画面操作</li>
        <li><strong>検索：</strong> 検索欄にラベル（作品名・製品名）を入力し「検索」。ヒットすると<strong>下の〇</strong>がその年にセットされ、スマホでは下の〇がヘッダの下に来るようスクロール。「前」「次」で別のヒットに移動。</li>
        <li><strong>表示切替：</strong> 「ジャンル」でフィルタリングして表示。</li>
        <li>スマホでは<strong>▼年＋</strong>と<strong>▲年－</strong>ボタンでチェックする年を変えていくことができます。</li>
      </ul>
      <h2>4. チェックリストとウェブ表示</h2>
      <p>下の〇を動かすと、その年の<strong>イベント一覧</strong>が表示されます。</p>
      <ul>
        <li><strong>チェックボックス：</strong> 診断に使う項目をチェック／解除。</li>
        <li><strong>地球マーク 🌐：</strong> PCではホバーでWikipedia等を右側にプレビュー。スマホではタップで画面の中央に大きく表示し、画面の他の部分をタップすると閉じる。</li>
      </ul>
      <h2>5. 診断とジャンル</h2>
      <p>10個以上チェックすると「診断」ボタンが押せます。チェック内容をもとに<strong>AI診断</strong>が実行されます。</p>
      <h5>ジャンル一覧（登録件数／総件数：${getTotalItemCount()}件）</h5>
      <ul>
        ${generateGenreListWithCounts()}
      </ul>
      <div class="credit">(c) 2026 Satoshi Endo / The timeline data for Xnative/Timeline is published under CC BY-SA 4.0.</div>
    `;
    openModal('ヘルプ - ネイティブマップ', helpHtml);
  });

  // ===== スモークテスト =====
  function runSmokeTests(){ try { renderEvents(); console.debug('[TEST] renderEvents (clip no-ellipsis): OK'); } catch(e){ console.error('[TEST] renderEvents threw', e); } }
  setTimeout(runSmokeTests, 0);
})();
</script>
</body>
</html>
